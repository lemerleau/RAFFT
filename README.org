RAFFT is a folding tool that builds fast-folding paths for a given sequence.
Starting from the completely unfolded structure, it quickly identifies stems
with an FFT-based technique. Then, it forms them if these stems improve the
overall stability. Multiple folding paths can be explored and displayed.
Therefore, given a sequence, the user will obtain several structures or folding
paths.

* Requirements
- Vienna RNA package (version >= 2.4.17)
- Numpy, scipy with python 3

* Usage
For the examples, we use the Coronavirus frameshifting stimulation element
obtained from RFAM.

To display only the final structures:
#+begin_src bash :results output
python rafft.py -s GGGUUUGCGGUGUAAGUGCAGCCCGUCUUACACCGUGCGGCACAGGCACUAGUACUGAUGUCGUAUACAGGGCUUUUGACAU  -ms 5 
#+end_src

To display the visited/saved intermediates:
#+begin_src bash :results output
python rafft.py -s GGGUUUGCGGUGUAAGUGCAGCCCGUCUUACACCGUGCGGCACAGGCACUAGUACUGAUGUCGUAUACAGGGCUUUUGACAU  -ms 5  --verbose
#+end_src

The algorithm has two critical parameters:
~-ms <INT>~ is the number of saved structures at each folding steps (default=1)
~-n  <INT>~ is the number of positional lag to search for stems (default=100)

The search of stems can be tuned using weights on base pairs types:
~--GC <FLOAT>~ GC base pairs weight (default = 3.0)
~--AU <FLOAT>~ AU base pairs weight (default = 2.0)
~--GU <FLOAT>~ GU base pairs weight (default = 1.0)

* Inputs
It takes as inputs either the sequence in the standard input or a simple text
file with only one sequence in it (it can be fasta format).

* Outputs
For the trajectory output format. At each steps, numbered from 0 to 3 here, the
structure saved are given below the sequence with their stability (computed with
Vienna RNA API).

#+begin_example
# ---------0----------
GGGUUUGCGGUGUAAGUGCAGCCCGUCUUACACCGUGCGGCACAGGCACUAGUACUGAUGUCGUAUACAGGGCUUUUGACAU
..................................................................................    0.0
# ---------1----------
GGGUUUGCGGUGUAAGUGCAGCCCGUCUUACACCGUGCGGCACAGGCACUAGUACUGAUGUCGUAUACAGGGCUUUUGACAU
.....(((((((((((..........))))))))))).............................................  -14.0
..................................((((((((................))))))))................   -6.8
...................(((((.............................................)))))........   -6.4
..................................((((.......)))).................................   -5.5
(((((..............)))))..........................................................   -4.6
# ---------2----------
GGGUUUGCGGUGUAAGUGCAGCCCGUCUUACACCGUGCGGCACAGGCACUAGUACUGAUGUCGUAUACAGGGCUUUUGACAU
........((((((((..........))))))))(((((((((((.........))).))))))))................  -23.1
........((((((((..........))))))))((((((((..((........))..))))))))................  -20.9
...................(((((..........(((((((((((.........))).))))))))...)))))........  -18.8
........((((((((..........))))))))((((((((...((....)).....))))))))................  -18.7
.....(((((((((((.((.....)))))))))))))....................((((((.............))))))  -18.2
# ---------3----------
GGGUUUGCGGUGUAAGUGCAGCCCGUCUUACACCGUGCGGCACAGGCACUAGUACUGAUGUCGUAUACAGGGCUUUUGACAU
........((((((((.((.....))))))))))(((((((((((.........))).))))))))................  -24.0
........((((((((.((.....))))))))))(((((((((((((....)).))).))))))))................  -24.0
........((((((((..........))))))))(((((((((((.........))).))))))))................  -23.1
........((((((((.((.....))))))))))((((((((..((........))..))))))))................  -21.8
........((((((((..........))))))))((((((((..((........))..))))))))................  -20.9
#+end_example

The output of the final structures only is the following.

#+begin_example
GGGUUUGCGGUGUAAGUGCAGCCCGUCUUACACCGUGCGGCACAGGCACUAGUACUGAUGUCGUAUACAGGGCUUUUGACAU
........((((((((.((.....))))))))))(((((((((((.........))).))))))))................  -24.0
........((((((((.((.....))))))))))(((((((((((((....)).))).))))))))................  -24.0
........((((((((..........))))))))(((((((((((.........))).))))))))................  -23.1
........((((((((.((.....))))))))))((((((((..((........))..))))))))................  -21.8
........((((((((..........))))))))((((((((..((........))..))))))))................  -20.9
#+end_example

* Analysis
** Fast-paths plot
To create path figures, one can use the utility ~utility/plot_path.py~ with on
rafft output:

*It uses [[http://varna.lri.fr][VARNA]] to produce the secondary structure representation, should be
download directly from its website*

#+begin_src bash :results output
cd example
python ../rafft.py -s GGGUUUGCGGUGUAAGUGCAGCCCGUCUUACACCGUGCGGCACAGGCACUAGUACUGAUGUCGUAUACAGGGCUUUUGACAU -ms 5 --verbose > rafft.out
python ../utility/plot_path.py rafft.out -he 500 -wi 900 -rv 1 -o path_5.png
#+end_src

#+RESULTS:

[[example/path_5.png]]

With 20 saved structures:

[[example/path_20.png]]

** Kinetic trajectory
From the above fast-folding paths, one can compute a derived kinetic model. It
uses the transitions obtained from the graphs shown above and simulate the
evolution of structure populations. The initial population is completely
unfolded.

#+begin_src bash :results output
cd example
python ../rafft.py -s GGGUUUGCGGUGUAAGUGCAGCCCGUCUUACACCGUGCGGCACAGGCACUAGUACUGAUGUCGUAUACAGGGCUUUUGACAU -ms 20 --verbose > rafft_20.out
python ../utility/kinetic.py rafft_20.out -ns 5000 -o kinetic.png --plot
#+end_src


where ~-ns~ is the number of integration steps.

In the output, the format is (the ~seq_id~ is also shown in the figure legend):

~<structure> <final population> <stability> <seq_id>~

#+begin_example
[...]
.....(((((((((((.((.....)))))))))))))(((((................)))))...................  0.000 -0.000 -17.6 26
.....(((((((((((..........)))))))))))......................(((........))).........  0.000 -0.000 -16.1 34
.....(((((((((((..........))))))))))).............................................  0.000 -0.000 -14.0 1
.....(((((((((((.((.....)))))))))))))(((((..((........))..)))))...................  0.001 -0.001 -21.0 50
.....(((((((((((.((.....)))))))))))))......................(((........))).........  0.003 -0.000 -17.0 28
.....(((((((((((..........)))))))))))....................((((((.............))))))  0.007 -0.000 -17.3 27
.....(((((((((((.((.....)))))))))))))....................((((((.............))))))  0.193 -0.000 -18.2 25
.....(((((((((((.((.....)))))))))))))((((((((.........))).)))))...................  0.795 -1.000 -23.2 44
#+end_example

[[example/kinetic.png]]
** Folding landscape
From the fast-folding paths graph, on can also derived a landscape using the
multidimensional scaling algorithm to map the structures onto a plan. It tries
to preserve as much as possible the base pair distance between structures.


#+begin_src bash :results output
cd example
python ../rafft.py -s GGGUUUGCGGUGUAAGUGCAGCCCGUCUUACACCGUGCGGCACAGGCACUAGUACUGAUGUCGUAUACAGGGCUUUUGACAU -ms 20 --verbose > rafft_20.out
python ../utility/surface.py rafft_20.out -o landscape.png
#+end_src

#+RESULTS:

(Initial and minimum energy structure are circled in black)

[[example/landscape.png]]

* Reproducibility of the benchmarks
The dataset curated we used for the benchmarks is in
~benchmarks_results/benchmark_cleaned_all_length.csv~.

The benchmark results files (and associated script to produce them) are given in
the following table (for details about those results, see the associated
reference):
|--------+---------------------------------------+-------------------------------|
| Method | file                                  | Notes                         |
|--------+---------------------------------------+-------------------------------|
| RAFFT  | ~rafft_100n_50ms_best_nrj_scores.csv~ | ~-n 100 -ms 50~ (best energy) |
|        | ~rafft_100n_50ms_scores.csv~          | ~-n 100 -ms 50~ (best score)  |
|        | ~rafft_200n_200ms_scores.csv~         | ~-n 200 -ms 200~ (best score) |
|--------+---------------------------------------+-------------------------------|
| MFE    | ~mfe_scores.csv~                      | ~bench_mfe.py~                |
|--------+---------------------------------------+-------------------------------|
| ML     | ~mxfold_scores.csv~                   | ~bench_mxfold.py~             |
|--------+---------------------------------------+-------------------------------|

~analysis.org~ and ~utils_analysis.py~ contain the pieces of script used to
perform the analysis and the figures.

For the test case, we used the command line given in the Usage section above.
Figures were derived from its output.
