* Compare algorithms

#+begin_src python :results output
from RNA import hamming_distance, bp_distance
import matplotlib.pyplot as plt
from matplotlib import rcParams, artist
from matplotlib.patches import Patch
from numpy import mean, std, median, linspace, arange
from utils import MCC_bench
from scipy.stats import kde
plt.rcParams["font.family"] = "serif"
plt.rcParams["font.weight"] = "bold"
plt.rcParams["font.size"] = 6.7
plt.rcParams["figure.figsize"] = 8, 4

def read_true_struct(infile="./test_data/benchmark_data_full.csv"):
    results = {}
    for l in open(infile):
        seq, struct, name = l.strip().split(",")
        results[seq] = struct
    return results

def read_csv(infile):
    # results = []
    results = {}
    first = True
    for l in open(infile):
        if not first:
            try:
                seq, len_seq, struct, nrj, nb_bp, name = l.strip().split(",")
            except:
                seq, len_seq, struct, nrj, nb_bp = l.strip().split(",")
            results[seq] = (int(len_seq), struct, float(nrj), int(nb_bp))
            # results += [(seq, int(len_seq), struct, float(nrj), int(nb_bp))]
        else:
            first = False
    return results

fft_pred = read_csv("./test_data/results_fft.csv")
vrna_mfe = read_csv("./test_data/results_mfe.csv")
targets = read_true_struct()

fft_to_plot, mfe_to_plot, fft_all_v, mfe_all_v  = {}, {}, [], []
# for (fft_seq, len_seq, fft_st, fft_nrj, fft_nbp), (mfe_seq, len_seq, mfe_st, mfe_nrj, mfe_nbp) in zip(fft_pred, vrna_mfe):
for fft_seq in fft_pred:
    len_seq, fft_st, fft_nrj, fft_nbp = fft_pred[fft_seq]
    len_seq, mfe_st, mfe_nrj, mfe_nbp = vrna_mfe[fft_seq]
    true_struct = targets[fft_seq]
    sens_fft, pcc_fft, F1_fft = MCC_bench(fft_st, true_struct)
    sens_mfe, pcc_mfe, F1_mfe = MCC_bench(mfe_st, true_struct)
    save_fft, save_mfe = pcc_fft, pcc_mfe
    fft_all_v += [save_fft]
    mfe_all_v += [save_mfe]

    if len_seq in fft_to_plot:
        fft_to_plot[len_seq] += [save_fft]
        mfe_to_plot[len_seq] += [save_mfe]
    else:
        fft_to_plot[len_seq] = [save_fft]
        mfe_to_plot[len_seq] = [save_mfe]


list_len = list(fft_to_plot.keys())
list_len.sort()
nb_el = len(list_len)
print(len(fft_all_v))
# fft_mean = mean(fft_all_v)
# mfe_mean = mean(mfe_all_v)
fft_mean = mean([mean(fft_to_plot[len_]) for len_ in list_len if len_ > 0])
mfe_mean = mean([mean(mfe_to_plot[len_]) for len_ in list_len if len_ > 0])

bpros = dict(color="orange", linewidth=0.2)
fig = plt.figure(1)

left, width = 0.1, 0.65
bottom, height = 0.1, 0.85
spacing = 0.000
rect_scatter = [left, bottom, width, height]
rect_histy = [left + width + spacing, bottom, 0.2, height]
# fft_f = fig.add_subplot(111)
fft_f = fig.add_axes(rect_scatter)

ax_histy = fig.add_axes(rect_histy, sharey=fft_f)
ax_histy.set_ylim([0, 100.0])
xs_scr = linspace(0, 100.0, 50)
dens_fft_scr = kde.gaussian_kde(fft_all_v)
dens_mfe_scr = kde.gaussian_kde(mfe_all_v)
ax_histy.plot(dens_fft_scr(xs_scr), xs_scr, c="deepskyblue", linewidth=0.8)
ax_histy.plot(dens_mfe_scr(xs_scr), xs_scr, c="orangered", linewidth=0.8)
ax_histy.tick_params(axis="y", labelleft=False, size=0)
ax_histy.tick_params(axis="x", labelbottom=False, size=0)
ax_histy.grid(True, color="grey",linestyle="--", linewidth=0.2)

fft_f.set_xlim([0, nb_el]); fft_f.set_ylim([0, 100.0])
fft_f.grid(True, color="grey",linestyle="--", linewidth=0.2)

fft_f.errorbar([i+0.0 for i in range(nb_el)], [mean(fft_to_plot[len_]) for len_ in list_len],
               yerr=[std(fft_to_plot[len_])/2 for len_ in list_len], elinewidth=0.8, fmt=".",
               linewidth=0.2, ms=3, label="FFT", c="skyblue", ecolor="skyblue", alpha=0.3)
fft_f.errorbar([i+0.0 for i in range(nb_el)], [mean(mfe_to_plot[len_]) for len_ in list_len],
               yerr=[std(mfe_to_plot[len_])/2 for len_ in list_len], elinewidth=0.8, fmt=".",
               linewidth=0.2, ms=3, label="FFT", c="coral", ecolor="tomato", alpha=0.3)

fft_f.scatter([i+0.0 for i in range(nb_el)], [mean(fft_to_plot[len_]) for len_ in list_len], c="deepskyblue", s=0.5)
fft_f.scatter([i+0.0 for i in range(nb_el)], [mean(mfe_to_plot[len_]) for len_ in list_len], c="orangered", s=0.5)
fft_f.plot([0, nb_el], [mfe_mean, mfe_mean], linestyle="--", c="tomato")
fft_f.plot([0, nb_el], [fft_mean, fft_mean], linestyle="--", c="skyblue")

fft_l = Patch(color="skyblue", label="FFT")
mfe_l = Patch(color="tomato", label="VRNA")

fft_f.xaxis.set_ticklabels(list_len[::20], rotation=45)
fft_f.xaxis.set_ticks([i for i in range(nb_el)][::20])

name_fft = "FFT"
name_mfe = "VRNA"
fft_f.set_title(f"PCC")
fft_f.legend((fft_l,mfe_l), (f"{name_fft}({fft_mean:4.1f})", f"{name_mfe}({mfe_mean:4.1f})"), loc="upper center", ncol=2)
# plt.savefig("img/comp_vrna_sens.png", dpi=300)
plt.show()
#+end_src

#+RESULTS:
: 3460
* Scoring

read structures
#+begin_src python :results output
from utils import paired_positions
import subprocess
import matplotlib.pyplot as plt
from matplotlib import rcParams, artist
from matplotlib.patches import Patch
from numpy import mean, std, median, linspace, arange
from scipy.stats import kde
from math import isnan
plt.rcParams["font.family"] = "serif"
plt.rcParams["font.weight"] = "bold"
plt.rcParams["font.size"] = 6.7
plt.rcParams["figure.figsize"] = 8, 4

def read_true_struct(infile="./test_data/benchmark_data_full.csv"):
    results = {}
    for l in open(infile):
        seq, struct, name = l.strip().split(",")
        results[seq] = (struct, name)
    return results


def read_csv(infile):
    results = {}
    first = True
    for l in open(infile):
        if not first:
            seq, len_seq, struct, nrj, nb_bp, name = l.strip().split(",")
            results[seq] = (int(len_seq), struct, float(nrj), int(nb_bp))
        else:
            first = False
    return results


def create_ct_file(struct, sequence, out_file, name):
    nb_base = len(sequence)
    pair_list = paired_positions(struct)
    pair_co = {}
    for pi, pj in pair_list:
        pair_co[pi] = pj
        pair_co[pj] = pi

    with open(out_file, "w") as out:
        out.write(f"{nb_base} {name}\n")
        for i, nuc in enumerate(sequence):
            base_id = i+1
            id_m1, id_p1 = i, i+2
            bp_id = pair_co[i]+1 if i in pair_co else 0
            nat_id = base_id
            out.write(f"{base_id} {nuc} {id_m1} {id_p1} {bp_id} {nat_id}\n")

            
def read_log_file(infile):
    for l in open(infile):
        if l.startswith("PPV"):
            pvv = float(l.strip().split()[-1][:-1])
        if l.startswith("Sensitivity"):
            sensitivity = float(l.strip().split()[-1][:-1])
            # nothing predicted
            if isnan(sensitivity):
                sensitivity = 0.0
    return pvv, sensitivity


fft_pred = read_csv("./test_data/results_fft.csv")
vrna_pred = read_csv("./test_data/results_mfe.csv")
true_str = read_true_struct()
print(len(true_str))
cmd_line = "/home/vaitea/programs/RNAstructure/exe/scorer {} {} {}"
raw_file = "./raw_data/archiveII/{}.ct"
fft_all_v, mfe_all_v = [], []
fft_to_plot, mfe_to_plot = {}, {}


for seq, (struct, name) in true_str.items():
    len_seq, fft_st, fft_nrj, fft_nbp = fft_pred[seq]
    len_seq, mfe_st, mfe_nrj, mfe_nbp = vrna_pred[seq]
    # create_ct_file(fft_st, seq, f"./log/{name}_fft.ct", name+"_fft")
    # create_ct_file(mfe_st, seq, f"./log/{name}_mfe.ct", name+"_mfe")
    # fft_cmd_line = cmd_line.format(f"./log/{name}_fft.ct", raw_file.format(name), f"./log/{name}_fft.log").split()
    # mfe_cmd_line = cmd_line.format(f"./log/{name}_mfe.ct", raw_file.format(name), f"./log/{name}_mfe.log").split()
    # subprocess.Popen(fft_cmd_line, stdout=subprocess.PIPE, env={'DATAPATH': '/home/vaitea/programs/RNAstructure/data_tables/'}).communicate()
    # subprocess.Popen(mfe_cmd_line, stdout=subprocess.PIPE, env={'DATAPATH': '/home/vaitea/programs/RNAstructure/data_tables/'}).communicate()
    fft_pvv, fft_sens = read_log_file(f"./log/{name}_fft.log")
    mfe_pvv, mfe_sens = read_log_file(f"./log/{name}_mfe.log")

    if fft_pvv < 0.1 and len_seq > 100:
        with open(f"scratch/bad_prediction/{name}_pred.log", "w") as out:
            out.write(f">{name}\n{seq}\n{fft_st}\n")
        with open(f"scratch/bad_prediction/{name}_true.log", "w") as out:
            out.write(f">{name}\n{seq}\n{struct}\n")
    save_fft, save_mfe = fft_pvv, mfe_pvv
    fft_all_v += [save_fft]
    mfe_all_v += [save_mfe]

    if len_seq in fft_to_plot:
        fft_to_plot[len_seq] += [save_fft]
        mfe_to_plot[len_seq] += [save_mfe]
    else:
        fft_to_plot[len_seq] = [save_fft]
        mfe_to_plot[len_seq] = [save_mfe]

list_len = list(fft_to_plot.keys())
list_len.sort()
nb_el = len(list_len)
# fft_mean = mean(fft_all_v)
# mfe_mean = mean(mfe_all_v)
fft_mean = mean([mean(fft_to_plot[len_]) for len_ in list_len if len_ > 0])
mfe_mean = mean([mean(mfe_to_plot[len_]) for len_ in list_len if len_ > 0])

bpros = dict(color="orange", linewidth=0.2)
fig = plt.figure(1)

left, width = 0.1, 0.65
bottom, height = 0.1, 0.85
spacing = 0.000
rect_scatter = [left, bottom, width, height]
rect_histy = [left + width + spacing, bottom, 0.2, height]
# fft_f = fig.add_subplot(111)
fft_f = fig.add_axes(rect_scatter)

ax_histy = fig.add_axes(rect_histy, sharey=fft_f)
ax_histy.set_ylim([0, 100.0])
xs_scr = linspace(min(fft_all_v), max(fft_all_v), 50)
dens_fft_scr = kde.gaussian_kde(fft_all_v)
dens_mfe_scr = kde.gaussian_kde(mfe_all_v)
ax_histy.plot(dens_fft_scr(xs_scr), xs_scr, c="deepskyblue", linewidth=0.8)
ax_histy.plot(dens_mfe_scr(xs_scr), xs_scr, c="orangered", linewidth=0.8)
ax_histy.tick_params(axis="y", labelleft=False, size=0)
ax_histy.tick_params(axis="x", labelbottom=False, size=0)
ax_histy.grid(True, color="grey",linestyle="--", linewidth=0.2)

fft_f.set_xlim([0, nb_el]); fft_f.set_ylim([0, 100.0])
fft_f.grid(True, color="grey",linestyle="--", linewidth=0.2)

fft_f.errorbar([i+0.0 for i in range(nb_el)], [mean(fft_to_plot[len_]) for len_ in list_len],
               yerr=[std(fft_to_plot[len_])/2 for len_ in list_len], elinewidth=0.8, fmt=".",
               linewidth=0.2, ms=3, label="FFT", c="skyblue", ecolor="skyblue", alpha=0.3)
fft_f.errorbar([i+0.0 for i in range(nb_el)], [mean(mfe_to_plot[len_]) for len_ in list_len],
               yerr=[std(mfe_to_plot[len_])/2 for len_ in list_len], elinewidth=0.8, fmt=".",
               linewidth=0.2, ms=3, label="FFT", c="coral", ecolor="tomato", alpha=0.3)

fft_f.scatter([i+0.0 for i in range(nb_el)], [mean(fft_to_plot[len_]) for len_ in list_len], c="deepskyblue", s=0.5)
fft_f.scatter([i+0.0 for i in range(nb_el)], [mean(mfe_to_plot[len_]) for len_ in list_len], c="orangered", s=0.5)
fft_f.plot([0, nb_el], [mfe_mean, mfe_mean], linestyle="--", c="tomato")
fft_f.plot([0, nb_el], [fft_mean, fft_mean], linestyle="--", c="skyblue")

fft_l = Patch(color="skyblue", label="FFT")
mfe_l = Patch(color="tomato", label="VRNA")

fft_f.xaxis.set_ticklabels(list_len[::20], rotation=45)
fft_f.xaxis.set_ticks([i for i in range(nb_el)][::20])

name_fft = "FFT"
name_mfe = "VRNA"
fft_f.set_title(f"PVV")
fft_f.legend((fft_l,mfe_l), (f"{name_fft}({fft_mean:4.1f})", f"{name_mfe}({mfe_mean:4.1f})"), loc="upper center", ncol=2)
# plt.savefig("img/comp_vrna_pvv.png", dpi=300)
plt.show()
#+end_src

#+RESULTS:

* compare loop contents
#+begin_src python :results output

#+end_src
* Test cases
Pick one a few sequences for testings

#+begin_src python :results output

#+end_src


