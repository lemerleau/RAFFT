* resutls statistical significance

#+begin_src python :results output
from utils import paired_positions
import subprocess
import matplotlib.pyplot as plt
from matplotlib import rcParams, artist
from matplotlib.patches import Patch
from numpy import mean, std, median, linspace, arange
from scipy.stats import kde, ttest_ind
from math import isnan
from RNA import fold_compound, bp_distance
from utils_analysis import get_loop_content
plt.rcParams["font.family"] = "serif"
plt.rcParams["font.weight"] = "bold"
plt.rcParams["font.size"] = 6.7
plt.rcParams["figure.figsize"] = 8, 4


def read_true_struct(infile="./kinetic_bench/benchmark_cleaned_red_all_length.csv"):
    results = {}
    for l in open(infile):
        seq, struct, name = l.strip().split(",")
        results[seq] = (struct, name)
    return results


def read_csv(infile):
    results = {}
    first = True
    for l in open(infile):
        if not first:
            seq, len_seq, struct, nrj, nb_bp, pvv, sens, name = l.strip().split(",")
            if struct != "Na":
                if pvv == "nan":
                    pvv = 0.0
                results[seq] = (int(len_seq), struct, float(nrj), int(nb_bp), float(pvv), float(sens))
        else:
            first = False
    return results


fft_pred = read_csv("./kinetic_bench/results_fft_all_length_100n_50ms_scores.csv")
# fft_pred = read_csv("./test_data/results_fft_100n_30_stack_scores.csv")
# line_pred = read_csv("./kinetic_bench/results_kinefold_scores.csv")
line_pred = read_csv("./kinetic_bench/results_fft_all_length_100n_50ms_best_nrj_scores.csv")
cont_pred = read_csv("./test_data/results_context_scores.csv")
mx_pred = read_csv("./test_data/results_mxfold_scores.csv")
vrna_pred = read_csv("./test_data/results_mfe_scores.csv")
# vrna_pred = read_csv("./test_data/results_mfe_scores.csv")
true_str = read_true_struct()
fft_all_v, mfe_all_v, cont_all_v, line_all_v, mx_all_v = [], [], [], [], []
fft_to_plot, mfe_to_plot, cont_to_plot, line_to_plot, mx_to_plot = {}, {}, {}, {}, {}

nb = 0
with open("analysis.log", "w") as out:
    for seq, (struct, name) in true_str.items():
        seq_comp = fold_compound(seq)
        true_loop_content = get_loop_content(struct)

        true_nb_bp = struct.count("(")
        true_nrj = seq_comp.eval_structure(struct)
        len_seq, mfe_st, mfe_nrj, mfe_nbp, mfe_pvv, mfe_sens = vrna_pred[seq]
        # if seq in fft_pred and seq in vrna_pred and seq in cont_pred and seq in line_pred and seq in mx_pred:
        # if seq in fft_pred and seq in vrna_pred and seq in line_pred:
        
        if seq in fft_pred and seq in line_pred and seq in mx_pred and len(seq) < 200:
            len_seq, fft_st, fft_nrj, fft_nbp, fft_pvv, fft_sens = fft_pred[seq]
            len_seq, line_st, line_nrj, line_nbp, line_pvv, line_sens = line_pred[seq]
            len_seq, mx_st, mx_nrj, mx_nbp, mx_pvv, mx_sens = mx_pred[seq]
            
            # len_seq, cont_st, cont_nrj, cont_nbp, cont_pvv, cont_sens = cont_pred[seq]
            # len_seq, mx_st, mx_nrj, mx_nbp, mx_pvv, mx_sens = mx_pred[seq]
            # save_fft, save_mfe, save_cont, save_line, save_mx = fft_pvv, mfe_pvv, cont_pvv, line_pvv, mx_pvv
            
            save_fft, save_mfe, save_line, save_mx = fft_pvv, mfe_pvv, line_pvv, mx_pvv
            fft_all_v += [save_fft]
            mfe_all_v += [save_mfe]
            line_all_v += [save_line]
            # cont_all_v += [save_cont]
            mx_all_v += [save_mx]

            if len_seq in fft_to_plot:
                fft_to_plot[len_seq] += [save_fft]
                mfe_to_plot[len_seq] += [save_mfe]
                line_to_plot[len_seq] += [save_line]
                # cont_to_plot[len_seq] += [save_cont]
                mx_to_plot[len_seq] += [save_mx]
            else:
                fft_to_plot[len_seq] = [save_fft]
                mfe_to_plot[len_seq] = [save_mfe]
                line_to_plot[len_seq] = [save_line]
                # cont_to_plot[len_seq] = [save_cont]
                mx_to_plot[len_seq] = [save_mx]

list_len = list(fft_to_plot.keys())
list_len.sort()
nb_el = len(list_len)

fft_mean = [mean(fft_to_plot[len_]) for len_ in list_len]
mfe_mean = [mean(mfe_to_plot[len_]) for len_ in list_len]
line_mean = [mean(line_to_plot[len_]) for len_ in list_len]
mx_mean = [mean(mx_to_plot[len_]) for len_ in list_len]
print(len(fft_all_v))
print(mean(fft_mean) - mean(mx_mean))
print(mean(fft_mean))
print(ttest_ind(mx_mean, fft_mean))
#+end_src

#+RESULTS:
: 1984
: 2.3222335391217115
: 79.04952429300945
: Ttest_indResult(statistic=-0.882471482720692, pvalue=0.3784432640336083)

0.8641114982578397
* Scoring

read structures
#+begin_src python :results output
from utils import paired_positions
import subprocess
import matplotlib.pyplot as plt
from matplotlib import rcParams, artist
from matplotlib.patches import Patch
from numpy import mean, std, median, linspace, arange
from scipy.stats import kde
from math import isnan
from RNA import fold_compound, bp_distance
from utils_analysis import get_loop_content
plt.rcParams["font.family"] = "serif"
plt.rcParams["font.weight"] = "bold"
plt.rcParams["font.size"] = 6.7
plt.rcParams["figure.figsize"] = 8, 4


def read_true_struct(infile="./kinetic_bench/benchmark_cleaned_red_all_length.csv"):
    results = {}
    for l in open(infile):
        seq, struct, name = l.strip().split(",")
        results[seq] = (struct, name)
    return results


def read_csv(infile):
    results = {}
    first = True
    for l in open(infile):
        if not first:
            seq, len_seq, struct, nrj, nb_bp, pvv, sens, name = l.strip().split(",")
            if struct != "Na":
                if pvv == "nan":
                    pvv = 0.0
                results[seq] = (int(len_seq), struct, float(nrj), int(nb_bp), float(pvv), float(sens))
        else:
            first = False
    return results


fft_pred = read_csv("./kinetic_bench/results_fft_all_length_200n_200ms_scores.csv")
# fft_pred = read_csv("./test_data/results_fft_100n_30_stack_scores.csv")
# line_pred = read_csv("./kinetic_bench/results_kinefold_scores.csv")
line_pred = read_csv("./kinetic_bench/results_fft_all_length_100n_50ms_scores.csv")
cont_pred = read_csv("./test_data/results_context_scores.csv")
mx_pred = read_csv("./test_data/results_mxfold_scores.csv")
vrna_pred = read_csv("./test_data/results_mfe_scores.csv")
# vrna_pred = read_csv("./test_data/results_mfe_scores.csv")
true_str = read_true_struct()
fft_all_v, mfe_all_v, cont_all_v, line_all_v, mx_all_v = [], [], [], [], []
fft_to_plot, mfe_to_plot, cont_to_plot, line_to_plot, mx_to_plot = {}, {}, {}, {}, {}

nb = 0
with open("analysis.log", "w") as out:
    for seq, (struct, name) in true_str.items():
        seq_comp = fold_compound(seq)
        true_loop_content = get_loop_content(struct)

        true_nb_bp = struct.count("(")
        true_nrj = seq_comp.eval_structure(struct)
        len_seq, mfe_st, mfe_nrj, mfe_nbp, mfe_pvv, mfe_sens = vrna_pred[seq]
        # if seq in fft_pred and seq in vrna_pred and seq in cont_pred and seq in line_pred and seq in mx_pred:
        # if seq in fft_pred and seq in vrna_pred and seq in line_pred:
        
        if true_loop_content[4] > 0.3:
            print(seq)
            print(struct)
        if seq in fft_pred and seq in line_pred and seq in mx_pred:
            len_seq, fft_st, fft_nrj, fft_nbp, fft_pvv, fft_sens = fft_pred[seq]
            len_seq, line_st, line_nrj, line_nbp, line_pvv, line_sens = line_pred[seq]
            len_seq, mx_st, mx_nrj, mx_nbp, mx_pvv, mx_sens = mx_pred[seq]
            
            # len_seq, cont_st, cont_nrj, cont_nbp, cont_pvv, cont_sens = cont_pred[seq]
            # len_seq, mx_st, mx_nrj, mx_nbp, mx_pvv, mx_sens = mx_pred[seq]
            # save_fft, save_mfe, save_cont, save_line, save_mx = fft_pvv, mfe_pvv, cont_pvv, line_pvv, mx_pvv
            
            if mfe_pvv < 10 and len_seq < 80:
                out.write("-"*10+"\n")
                out.write(f"{fft_pvv} {mfe_pvv}\n")
                out.write(f"FFT = {fft_nrj} TRUE = {true_nrj} MFE = {mfe_nrj}\n")
                out.write(f"LEN {len_seq}\n")
                out.write(f"{seq}\n")
                out.write(f"{fft_st}\n")
                out.write(f"{mfe_st}\n")
                out.write(f"{struct}\n")

            save_fft, save_mfe, save_line, save_mx = fft_sens, mfe_sens, line_sens, mx_sens
            fft_all_v += [save_fft]
            mfe_all_v += [save_mfe]
            line_all_v += [save_line]
            # cont_all_v += [save_cont]
            mx_all_v += [save_mx]

            if len_seq in fft_to_plot:
                fft_to_plot[len_seq] += [save_fft]
                mfe_to_plot[len_seq] += [save_mfe]
                line_to_plot[len_seq] += [save_line]
                # cont_to_plot[len_seq] += [save_cont]
                mx_to_plot[len_seq] += [save_mx]
            else:
                fft_to_plot[len_seq] = [save_fft]
                mfe_to_plot[len_seq] = [save_mfe]
                line_to_plot[len_seq] = [save_line]
                # cont_to_plot[len_seq] = [save_cont]
                mx_to_plot[len_seq] = [save_mx]


list_len = list(fft_to_plot.keys())
list_len.sort()
nb_el = len(list_len)

fft_mean = mean([mean(fft_to_plot[len_]) for len_ in list_len if len_ > 0])
mfe_mean = mean([mean(mfe_to_plot[len_]) for len_ in list_len if len_ > 0])
line_mean = mean([mean(line_to_plot[len_]) for len_ in list_len if len_ > 0])

# cont_mean = mean([mean(cont_to_plot[len_]) for len_ in list_len if len_ > 0])
mx_mean = mean([mean(mx_to_plot[len_]) for len_ in list_len if len_ > 0])

slide_mean_fft = [mean([mean(fft_to_plot[l]) for l in list_len[max(0, i-10):min(nb_el, i+10)]]) for i, len_ in enumerate(list_len)]
slide_mean_mfe = [mean([mean(mfe_to_plot[l]) for l in list_len[max(0, i-10):min(nb_el, i+10)]]) for i, len_ in enumerate(list_len)]
slide_mean_line = [mean([mean(line_to_plot[l]) for l in list_len[max(0, i-10):min(nb_el, i+10)]]) for i, len_ in enumerate(list_len)]
# slide_mean_cont = [mean([mean(cont_to_plot[l]) for l in list_len[max(0, i-10):min(nb_el, i+10)]]) for i, len_ in enumerate(list_len)]
slide_mean_mx = [mean([mean(mx_to_plot[l]) for l in list_len[max(0, i-10):min(nb_el, i+10)]]) for i, len_ in enumerate(list_len)]

bpros = dict(color="orange", linewidth=0.2)
fig = plt.figure(1)

left, width = 0.1, 0.65
bottom, height = 0.1, 0.85
spacing = 0.000
rect_scatter = [left, bottom, width, height]
rect_histy = [left + width + spacing, bottom, 0.2, height]
# fft_f = fig.add_subplot(111)
fft_f = fig.add_axes(rect_scatter)

ax_histy = fig.add_axes(rect_histy, sharey=fft_f)
ax_histy.set_ylim([0, 100.0])
xs_scr = linspace(min(fft_all_v), max(fft_all_v), 50)
dens_fft_scr = kde.gaussian_kde(fft_all_v)
dens_mfe_scr = kde.gaussian_kde(mfe_all_v)
dens_line_scr = kde.gaussian_kde(line_all_v)
# dens_cont_scr = kde.gaussian_kde(cont_all_v)
dens_mx_scr = kde.gaussian_kde(mx_all_v)
ax_histy.plot(dens_fft_scr(xs_scr), xs_scr, c="deepskyblue", linewidth=0.8)
ax_histy.plot(dens_mfe_scr(xs_scr), xs_scr, c="orangered", linewidth=0.8)
ax_histy.plot(dens_line_scr(xs_scr), xs_scr, c="green", linewidth=0.8)
# ax_histy.plot(dens_cont_scr(xs_scr), xs_scr, c="blueviolet", linewidth=0.8)
ax_histy.plot(dens_mx_scr(xs_scr), xs_scr, c="blueviolet", linewidth=0.8)
ax_histy.tick_params(axis="y", labelleft=False, size=0)
ax_histy.tick_params(axis="x", labelbottom=False, size=0)
ax_histy.grid(True, color="grey",linestyle="--", linewidth=0.2)

fft_f.set_xlim([0, nb_el]); fft_f.set_ylim([0, 100.0])
fft_f.grid(True, color="grey",linestyle="--", linewidth=0.2)

fft_f.errorbar([i+0.0 for i in range(nb_el)], [mean(fft_to_plot[len_]) for len_ in list_len],
               yerr=[std(fft_to_plot[len_])/4 for len_ in list_len], elinewidth=0.8, fmt=".",
               linewidth=0.2, ms=3, c="skyblue", ecolor="deepskyblue", alpha=0.2)
fft_f.errorbar([i+0.0 for i in range(nb_el)], [mean(mfe_to_plot[len_]) for len_ in list_len],
               yerr=[std(mfe_to_plot[len_])/4 for len_ in list_len], elinewidth=0.8, fmt=".",
               linewidth=0.2, ms=3, c="coral", ecolor="orangered", alpha=0.2)
# fft_f.errorbar([i+0.0 for i in range(nb_el)], [mean(cont_to_plot[len_]) for len_ in list_len],
#                yerr=[std(cont_to_plot[len_])/4 for len_ in list_len], elinewidth=0.8, fmt=".",
#                linewidth=0.2, ms=3, c="blueviolet", ecolor="blueviolet", alpha=0.2)
fft_f.errorbar([i+0.0 for i in range(nb_el)], [mean(line_to_plot[len_]) for len_ in list_len],
               yerr=[std(line_to_plot[len_])/4 for len_ in list_len], elinewidth=0.8, fmt=".",
               linewidth=0.2, ms=3, c="palegreen", ecolor="palegreen", alpha=0.2)
fft_f.errorbar([i+0.0 for i in range(nb_el)], [mean(mx_to_plot[len_]) for len_ in list_len],
               yerr=[std(mx_to_plot[len_])/4 for len_ in list_len], elinewidth=0.8, fmt=".",
               linewidth=0.2, ms=3, c="blueviolet", ecolor="blueviolet", alpha=0.2)

fft_f.scatter([i+0.0 for i in range(nb_el)], [mean(fft_to_plot[len_]) for len_ in list_len], c="deepskyblue", s=0.5)
fft_f.scatter([i+0.0 for i in range(nb_el)], [mean(mfe_to_plot[len_]) for len_ in list_len], c="orangered", s=0.5)
fft_f.scatter([i+0.0 for i in range(nb_el)], [mean(line_to_plot[len_]) for len_ in list_len], c="green", s=0.5)
# fft_f.scatter([i+0.0 for i in range(nb_el)], [mean(cont_to_plot[len_]) for len_ in list_len], c="blueviolet", s=0.5)
fft_f.scatter([i+0.0 for i in range(nb_el)], [mean(mx_to_plot[len_]) for len_ in list_len], c="blueviolet", s=0.5)

fft_f.plot(range(nb_el), slide_mean_fft, linestyle="--", c="deepskyblue", alpha = 0.8)
fft_f.plot(range(nb_el), slide_mean_mfe, linestyle="--", c="orangered", alpha = 0.8)
fft_f.plot(range(nb_el), slide_mean_line, linestyle="--", c="green", alpha = 0.8)
# fft_f.plot(range(nb_el), slide_mean_cont, linestyle="--", c="blueviolet", alpha = 0.8)
fft_f.plot(range(nb_el), slide_mean_mx, linestyle="--", c="blueviolet", alpha = 0.8)

fft_l = Patch(color="skyblue", label="FFT")
mfe_l = Patch(color="tomato", label="VRNA")
line_l = Patch(color="green", label="Line")
cont_l = Patch(color="blueviolet", label="Cont")
mx_l = Patch(color="blueviolet", label="Mxfold")

fft_f.xaxis.set_ticklabels(list_len[::20], rotation=45)
fft_f.xaxis.set_ticks([i for i in range(nb_el)][::20])

name_fft = "RAFFT"
name_mfe = "MFE"
name_cont = "ContextFold"
name_line = "RAFFT*"
name_mx = "Mxfold"

fft_f.set_title(f"Sensitivity")
# fft_f.legend((fft_l,mfe_l,line_l,cont_l, mx_l), (f"{name_fft}({fft_mean:4.1f})", f"{name_mfe}({mfe_mean:4.1f})",
#                                     f"{name_line}({line_mean:4.1f})", f"{name_cont}({cont_mean:4.1f})",
#                                     f"{name_mx}({mx_mean:4.1f})"), loc="bottom center", ncol=3)
fft_f.legend((fft_l,mfe_l,line_l,mx_l), (f"{name_fft}({fft_mean:4.1f})", f"{name_mfe}({mfe_mean:4.1f})",
                                    f"{name_line}({line_mean:4.1f})", f"{name_mx}({mx_mean:4.1f})"), loc="lower center", ncol=4)
plt.savefig("img/fold_perf_200_sens.png", dpi=300)
plt.show()
#+end_src

#+RESULTS:
#+begin_example
AGUUGUAAAAAACUCCAGCUGAUAUAAAAUAAACUACGAAAGUGGCUUUAAUAUAUCUGAACACACAAUAGCUAGGACCCAAACUGGGAUUAGAUACCCCACUAUGCCUAGCCCUAAACUUCAACAGUUAAAUUAACAAGACUGCUCGCCAGAACACUACGAGCCACAGCUUAAAACUCAAAGGACCUGGCGGUGCUUCACAUCCUUCUAGAGGAGCCUGUUCUGUAAUCGAUAAACCCCGAUCAACCUCACCACCUCUUGCUCAGCCUAUAUACCGCCAUCUUCAGCAA
.(((......)))....................(.((....)))..........................((((((...((...((((.........))))...))))))))..........(.(((((..........))))).).....((.......((((....)))).....))................................................((((........))))...............................................
AAUCAGGCUUAGCGGGGAGGACGUGGACCAGCGAGGGUGACGCGCUGCGUUGACGUGGUGCUCUGCUUGGCUGUGUGUCGGUGUGACCCGCACCCCUGCAGAGGGGUGGCGCGGGCCCGCCGUUGAAGCGAGGGAACC
..............................................................................(((.((...(..(((((((....)))))))..)...)))))...(...)...........
CACUCGUGCGAGUAAUCCACGAUCUGCUGUGGCGCGCUAAGCCCUGGCCCGGACCCUCGAGGGAAGCGAUUCUGCAGAGAACAGGACCCCCGGAGAUGGCGGCGCCAGACUACACCCUCGCUGCACA
((.(((((.((....)))))))..)).........((...))...((.((.....(((....(((....)))....)))....)).)).......................................
GUGCUAGACGGGGAGGUAGCGGUGCCCUGUUACCUGCAAUCCGCUAUAGCAGGGUCGAAUUCCUAUAAUAGGCAUGCUUCUGUAAGGUCUGCCCUUUGCAAGUGGCGAUGAAAAUUGGGUCCUACGCAACGGAAGCCUAUGAACCCCGUCAGGUUCGGAAGAAAGCAGCGGUAAG
......(((((((.(.(...).).))))....(((((...........))))))))...................................................................................(.....((((....(((....)))....))))...)
GUCGGGCGGACGCAGCCUUCGCCAACCCGGUCAGGUCCGGAAGGAAGCAGCCGCAACGAAUU
.................((((......((((....(((....)))....))))...))))..
CACUCGUGCGAGUAAUCCACGAUCUGCUGUGGCGCGCUAAGCCCUGGCCCGGACCCUCGAGGGAAGCGAUUCUGCAGAGAACAGGCCCCCCGGAGAUGGCGGCGCCAGACUACACCCUCGCUGCACA
((.(((((.((....)))))))..)).........((...))...((.((.....(((....(((....)))....)))....)).)).......................................
CACUCGAUGCGAGUAAUCCACGAUCUGCUGUGGCGCGCUAAGCCCUGGCCCGGACCCUCGAGGGAAGCGAUUCUGCAGAGAACAGGCCCCCCGGAGAUGGCGGCGCCAGACUACACCCUCGCUGCACA
((.(((.((.((....)))))))..)).........((...))...((.((.....(((....(((....)))....)))....)).)).......................................
GGUGGUCUGCCCGUUCCAAGUUGAGUAGUGGACCGCUUGGGGCCUAUGCGAAAGUUGGGCCUCACGGUCCAUAAUGUGGCAGGCACCGCGUGAGGCUGGCUUCACAGAGCAGCGACAACUGCCCGCUUCCAACGGUGGAAGGAUAACGGGCCGCUGCACUCCUAGGCCGCUUGGGCCUCGUAGCCUACUCCAGCGACCACCAUC
.((((((((.((.(((((.((((.(.(((.(((((..(((((((((.((....))))))))))))))))((...)).(((((......(((....(((......)))....)))....))))).))).)))))..)))))))....))))))))..................................................
AACCAGGCUUAGCGGGGAGGACGUGGACCAGCGAGGGUGAUUUGCUGCGUUGACGUGGUGCUCUGCUUGGCUGUGUGUCGGUGUGGCUUGCCCCCCUGCAGAGGGUGGCGCGGGUCCGCCGUUGAAGCGAGGGAACC
..............................................................................(((.((..(.((((.((((....)))).)))).).)))))...(...)...........
AAUGCGUUAGGCUGGUUUCACAGAGCUGCGAGAACCUCACGCUCUACACAGUGUAAGGAUUACA
..(.(((....(((......)))....))).)................................
UGAACCCCCCCAGGGCCGGAAGGCAGCAAGGGUAAGCGGGCUCUGACGGGUG
(.....(((.....(((....))).....)))..).................
GGGCAAAGCGUGAGGCUGGUUUCACAGAGCAGCGACAACCUCCCUCUCCUUGCAGUGGAAGGAUAAC
((......(((....(((......)))....)))....))...........................
CGCAACACUACCUUGUGAACUCGGUCAGGUCCGGAAGGAAGCAGCCGCAGCAAGCGACGUGUGUGCCGGGAUGUCGCUGGCGGGGCCUCCACC
(((.((((...(((((.....((((....(((....)))....))))..)))))....)))))...)).........................
GAACCGGGUCAGGUCCGGAAGGAAGCAGCCCUAAG
.....((((....(((....)))....))))....
UCCUAGGUGGAGCGGGGGUGUCGUGGACCAGCGAGGGUGGCGCGCUGCGUUGACGCGGUGCUCUGCUUGGCUGUGUGUCGGUGUGGCCUGCCCCCCUGUAGAGGGGUGUCGUAGGCUACCCGUUGAAGCGAGGGAAACC
................................................................................(.((...(.((.(((((....))))).)).)...))).....(...)............
UGAACUCCCCCAGGGCCGGAAGGCAGCAAGGGUCAAUGGGCUCUGGCGGGUGCGCGGGG
(.....(((.....(((....))).....)))...).......................
CCGUGCUAGAUGGGGAGGUAGCGGUGCCCUGUAACCCGCAAACCGCUAUAGCGGGGUUGAAGUCCCA
........(((((((.(.(...).).))))....(((((...........)))))))).........
AGGCUAGGCCGGGGGGUUAGGGGUCCCCUGUAAGCGCAAAUCCCCUAUAUGGCGCGGCCGAAGCCCAGGAGGCGGCAAGACCGCCAGACAUCGGCCUGAGGGUUAAACAAUGAAGCCUCGUCCCACAGGGCCACCGGUGGCGAGGGUCCAGCUG
......(((((((((((.....)))))))....((((.(..........).))))))))...............................................................................................
GUGAACCCGGUCAGGCCCGGAAGGGAGCAGCCGAAGCGGUGGAUGUGUGUGCCG
((.....((((....(((....)))....))))..)).................
UGAACUCCCCCAGGGCCGGAAGGCAGCAAGGGUAAGCGGGCUCUGGCGGGUGC
(.....(((.....(((....))).....)))..)..................
GAAUUCAACGUAUAAACGAGACACAUGCAUAUAUUUUGUUAUGUGUAGACAGAUGGUUACCACCAACGAUCCAGUGUAACUAGUGCACGUGAUGAGUACAAUGGAACAGAACCCGGCUUA
....................(((((((((.(...).)).)))))))................(((..(..(..(((((.....))))).......)..)..)))................
GGAGCAACACUUGUGCGUGAAGUGGGUCAGGGGAGGAAUCCAGCAGCCCUAAGCGAU
...............(((.....((((....(((....)))....))))...)))..
GAACCUCCCCAGGGCCGGAAGGCAGCAAGGAUAAGCGGGCUCUGGCGGGUGCACGGGGGGCCUU
.....(((.....(((....))).....))).................................
CAACACCUAAACCUUGUCAGGACCGGAAGGUAGCAGCAACACGGGAUGCUUGUAGUAGGCGUUGACUCCGGGUC
((((((((.....((((....(((....)))....))))...))).)).)))......................
GGCGGGGGGCUGCGCGGCGCGCCGGCCGCGCUCCGCCGAUGGGCGGACCCAGGCUUGGGGGCCCGAAACCGGGGCCGGGCGGCGCCUCCUGCGGCGUUCCGCCCAGGCUUACCGAGGAGCCCCGGUCCAGCGGGGCGCCAGUCCCCGGCUAGCUCGGCCGUAGGGCCGAGUCAAGCCGGGCAUGCGGGGAACCGGCGGAGGUCCGGGAGGGAGCACGCCUAACCCGCAGCUGGCGCGUUC
...........((.(((.((((.....)))).)))....(.((...........)).)..)).....................................................................((.((((((((.((((..(.((((((((....)))))))).)..).)))..((((((.....((((....(((....)))....))))...)))))))))))))).)).
CCGUGAACCUGGUCAGGCCCGGAAGGGAGCAGCCACAGCGGUGGAUCUGUGUGCCGGGGUGUGGCUGGUAGGGC
((((.....((((....(((....)))....))))..)))).................................
GUGUUCGUUCUUGGUCUACUGAUAUCGCACUCUUUUGGGCUGACUUAAGCUCGGCUUAAUGCUUAAAUUACUGCAAAGGUAGUGUGACUCGAUUGUUUUCUUCAAGUUCCAACAAUCGUGAAAAAUAUGUGAUGAUCAGGGGCUGAGCUAACGCGUUAAACACUCCGCCUGGGGAGUACGGUCGCAAGGCUGAAACUCAAAGAAUUGACGGGGGCCUGCACAAGCGGUGGAGCAUGUGGUUUAAUUCGAUUCAACGCGCAAAACCUUACCAGCCCUUGACAUAUGAAUAAGUGUGCUUGUCCUUAACGGGAUGGUACGAAAAUUCAUACAGGUGUUGCAUGGCUGUCGUCAGCUCGUGUCUUGAGACGUUGGGUUAAGUCCUAUAACGAGCGCAACCCUUGUUUUGUGUUGCUAAGACAUGCUUUGGUUCAAUCCUUGACCACUGGAGACUGACGAAGACUACGCCGUGAAAAUGGAGGAUACCGA
.((((.((((((((((.....................................................................................................................))))))))))...((....))....))))........(((......((((....))))....)))..............................................(.((........)).).....................((((((........(((((.....)))))............)))))).......................(((((((((....)))..((((......))))..))))))...............................................................................................
CUGAACCCCCCCAGGGCCGGAAGGCAGCAAGGGUAGGUGGGCCCUGGCGGGUG
((.....(((.....(((....))).....)))..))................
GAAUCGCGAGUAAUCGUAGAUCAUUAGCGCUACGGUGAAGGUAACCUCUAUUGUGCACACAUUGCCCGUCACCUCCGAUAAUAGUAUUGUACAGGAAGAACUAUGGCUACACUUA
............(((((((..........)))))))...............................................................................
GGCGGGGGGCUGCACGGCGUGCCGGCCGUGCUCCGCCGGAAGGCGGACCCAGGCUUGGGGGCCCGAAACCGGGGCCGGGCGGCGUCUCCGGCGGCGUGCCGCCUGGGCUUACCAAUGAGCUCCGGUCCAGGGGGGCGCCAGUCCCCAGGCUACCCCGGCCGUAGGGCCGGGGGGACCUGGGCAUGCGGGGAAACGGCGGAGGUCCGGGAGGGAGCACGCCUAACCCGCAGCUGGCGCGUUCCCU
...........((.(((.((((.....)))).)))......((...........))....))...................................................................((((.((((((((.((((((.(.((((((((....)))))))).).))))))..((((((.....((((....(((....)))....))))...)))))))))))))).))))..
UGGCUAGGCUGGGAAGUUAGGCGUUUCCUGUAACUCGAAAUCGCCUUUGCGAGAGCCGAAAACUUGAGGGCGGUUUUAAAUUCUGUCAUUCAUUCUCAAGUUUUGUGUAGACAUUUCGUCCUUUGGGGUAAGAUGGCAGAGGAACCUUUUUUGGAAGAAAAAGACAAACCUCUUUUAUCUUUCGAACCCCGUCAGGCCCGGAAGGGAGCAGCGGUAGA
......(((((((((((.....)))))))....((((............))))))))..............................................................................(.(((((...(((((((....))))))).....))))).)......((.....((((....(((....)))....))))..))
AAUCAGUCUGUUACAUUCUAGCAAUGAGUAGCACCAUCACUGGAGGGAAGCAAUUCAGCACAGUAUGUUACCCGUGGUGGAGGCGAAACGGACGGCAC
.....................(...).((((((.....((((....(((....)))....)))).))))))...........................
AGGCAAGGUUGGACUUACGAAUUGUGUCAGGUCCGGAAGGAAGCAGCACUAAGUAUGCU
.............(.(((.....((((....(((....)))....))))...))).)..
UCGCCAACCCGGUCAGGUCCGGAAGGAAGCAGCCGUAACGAGUUUUGCUCGGGUCGUU
(((......((((....(((....)))....))))...))).................
UCCUAGGUGGAGCGGGGGUGUCGUGGACCAGCGAGGGUGGCGCGCUGCGUUGACGCGGUGCUCUGCUUGGCUGUGUGUCGGUGUGGCCUGCCCCCCUGUAGAGGGGUGUCGUAGGCUACCCGUUGAAGCGAGGGAAA
................................................................................(.((...(.((.(((((....))))).)).)...))).....(...)..........
GGAAAGGUAUACCGCCCCAGGCUGGUAAACAGAGCAGGGAAAAGCCCUCGCUCUUGGUAGUGGGAGGAUCUCGUAUCAGAAUUCUGAUGUG
...(.(((......(((....(((.....)))....)))....))).)...........................................
UGGGCCCCACGCAACGGAAGGUUACGAACUCCGUCAGGUCCGGAAGGAAGCAGCGG
..............................((((....(((....)))....))))
GUGCUAGACGGGGAGGUAGCGGUGCCCUGUAACCUGCAAUCCGCUAUAGCAGGGUUGAAUUCCUCAUGGAGGCUUGUUGCUUGUAGGGCUGGCCUAGAUAAGUGGUGAUGAGAAUUGGGUCCUACGCAAUGAAAACUCAUGAACUCCGUCAGAUCCGGAAGGAAGCAGCGGUAAG
......(((((((.(.(...).).))))....(((((...........))))))))...................................................................................(.....((((....(((....)))....))))...)
GGCGGGGGGCUGCGCGGCGUGCCGGCCGCGCGCCGCCGAAAGGCGGACCCAGGCUAGGGAGCCCGAAACUGGGGCCGGGCGGCGCCUCCUGCGGCGUCCCGUCUUGGCUUACCGAUGAGCACCGGUCCAGGGGGGCGCCGGUCCCCAGGCUACCCCGGCCGUAGGGCCGGGGGGACUUGGGUAUGCGGGGAACAGGCGGAGGUCCGGGAGGGAGCACGCCUAACCCGUAGCCGGCGCGUUCCCU
...........((.((((((((.....)))))))).......(...........).....))...................................................................((((.((((((((.((((((.(.((((((((....)))))))).).))))))..((((((....(((((....(((....)))....)))))..)))))))))))))).))))..
UGGCUAGGCUGGGAAGUUAGGCGUUUCCUGUAACUCGAAAUCGCCUUUGCGAGAGCCGAAAACUUGAGGGCGGUUUUAAAUUCUGUCAUUCAUUCUCAAGUUUUGUGUAGACAUUUCGUCCUUUGGGGUAAGAUGGAGGAGGAACCUUUUUUGGAAGAAAAAGACAAACCUCCCUUAUCUUUCGAACCCCGUCAGGCCCGGAAGGGAGCAGCGGUAGA
......(((((((((((.....)))))))....((((............))))))))..............................................................................(.(((((...(((((((....))))))).....))))).)......((.....((((....(((....)))....))))..))
AGUGGGGGCAUUAAGGUGGUGUGGACGCUGUUGUAGCGCUGCAAGCUUGGUCUAUGUAUGCUACUGUUGGCCCGCCCGUUCCAAGUUGAGUAGUGGACCGCUUGGGGCCUAUGCGAAAGUUGGGCCUCACGGUCCAUAAUGUGGCAGGCACCGCGUGAGGCUGGCUUCACAGAGCAGCGACAACUGCCCGCUUCCAACGGUGGAAGGAUAACGGGCCGCUGCA
..........................................................((.((....(((((((.((.(((((.((((.(.(((.(((((..(((((((((.((....))))))))))))))))((...)).(((((......(((....(((......)))....)))....))))).))).)))))..)))))))....))))))).))))
AGGGCAGAUCGGGCAAUCGCGGGGGAUGCAAAUCCUUCGAGGAAGGUCCGGACUCCACAGGGCGGGAUAGCGGCUAACGGCCGUCCGGCGACGCUGGCGGGCUUGCCCGCCGGAAAAGCCGAGGAACAGGGCCACAGAGACGAGUCUGUCAUGAGGGCGCGCCUGGCGCGCACCGGCACGGCCAUCUCCGUGCCGCGCCGUCCGGAAACGGGCGGCGGCAUGACAGGGUGAAACGCGGCAACC
...................((((((((....))))))))..............................(((((.....)))))(((((....((((((((....))))))))....)))).).....(((((...........(((((((((.(.((((((...)))))).)((((((((......))))))))(((((((((....))))))))).))))))))).........)))..))
GAACCCCGCCAGGCCCGGAAGGGAGCAACGGUAGUAGUAUAAUUGUGUGCCGGGGUGUGGCUGG
.....(((.....(((....))).....))).................................
AGCUGUAAUGGCUCAAUGGUGGAAUUGUACACCUUGGGAUUUCUGACUUUGGUUCAAUCCUCGCAGUCGGACGUAGGUUAGCAUGUCACGUUUCGGCGUGGCAAGGGGUACUCACCUUCCCGUGGGGUCCGCACUGCGCGUCGGCGACAACCGUCAUCCUUCUCUCGCUUCCAGUUGCCGAGGCCGUCAAUCUUGGCGGUCUCAGAGAGAGGGACUCGGGGUUAACGUGUCCCGGUUAUUAUC
(((.......)))............................(((((((.(((........))).)))))))(((.((.(.....(((((((....)))))))..(((.(.(.............).))))..))))))....................((((((((.............((((((((((....)))))))))).))))))))...............................
UGAACCCCCCCAGGGCCGGAAGGCAGCAAGGGUAAGCGGGCUCUGGCGGGUG
(.....(((.....(((....))).....)))..).................
GGGCAAUGCGUUAGGCUGGUUUCACAGAGCUGCGAAAACUUCACGCUCUGAACAGUGGAAGGAU
((....(.(((....(((......)))....))).)..))........................
GAACCCCGUCAGGUCCGGAAGGAAGCAGCGGUAAGU
.....((((....(((....)))....)))).....
#+end_example

* Explore data

#+begin_src python :results output
from utils import paired_positions
import subprocess
import matplotlib.pyplot as plt
from matplotlib import rcParams, artist
from matplotlib.patches import Patch
from numpy import mean, std, median, linspace, arange
from scipy.stats import kde
from math import isnan
from RNA import fold_compound, bp_distance
from utils_analysis import get_loop_content
plt.rcParams["font.family"] = "serif"
plt.rcParams["font.weight"] = "bold"
plt.rcParams["font.size"] = 6.7
plt.rcParams["figure.figsize"] = 8, 4


def read_true_struct(infile="./kinetic_bench/benchmark_cleaned_all_length.csv"):
    results = {}
    for l in open(infile):
        seq, struct, name = l.strip().split(",")
        if seq in results:
            results[seq] += [(struct, seq, name)]
        else:
            results[seq] = [(struct, seq, name)]
    return results


true_str = read_true_struct()
tot = []
with open("./kinetic_bench/benchmark_cleaned_red_all_length.csv" ,"w") as out:
    for seq in true_str:
        struct, seq, name = true_str[seq][0]
        if len(true_str[seq]) > 1:
            seq_comp = fold_compound(seq)
            if len(set([st for st, s_, n_ in true_str[seq]])) > 1:
                tot += [len(true_str[seq])]
                min_st, min_nrj = min([(st, seq_comp.eval_structure(st)) for st, s_, n_ in true_str[seq]], key=lambda el: el[1])
                struct = min_st
                print(seq, len(seq))
                for st in set([st for st, s_, n_ in true_str[seq]]):
                    print(st)
            # else:
                
        out.write(f"{seq},{struct},{name}\n")
        
print(mean(tot))
print(min(tot))
print(max(tot))
print(len(tot))
#+end_src

#+RESULTS:
#+begin_example
CUCUUAUUUAGACCUAUGCAAUAGGAUUUUAGGGUAACGCUUCAGGGUAGGAAUACAGCAGAGUCCCCUAAUUUCUUGUGUGCCUUAGCCAUCUGAAUAGGAG 103
..(((.(.(.(..(((.((.((((((..((((((....((((....(((....)))....)))).))))))..)))))))...).))).....)..).).)))
((((((((((((.(((.((.((((((..((((((....((((....(((....)))....)))).))))))..)))))))...).)))...))))))))))))
GACGGGCCUCCUCGCAUGGUGGGGCGGUCAACCUGGUCAGGUCGGGAACGAAGCAGCCACAGCCGUUUUCCGCCAGUGCCGAGGGUCGGGCUCGUC 96
(((((((((((((((.((((((((((((.....((((....(((....)))....))))..))))))..)))))))...))))))...))))))))
(((((((((((((((.((((((((((((.....((((....(((....)))....))))..))))))..)))))))...))))))..)).))))))
GGCGUGCGCCUGUAAUCCAGUUACUUGGAGGCUUGGGUUGGAGGACGGUGUGAGAUUGGGAGCUCUGUGGCGCUCUGUCCUCUGUCCUAUGUCGAUCGGGCGUCCGCGCUAAGCUCGGCGUCAAUAUGGGCAUUCCAGGGGAGCCCGGAGUGGCCAGGUUGUCCAAGGAGGAACGCACCGGGCGAGGCCCGAAAGGGAGCAGCCAAAAGUUCCCACGUUGAUCAGUAGCGGGAUAGCGCCUGUGAAUAGGCGGAGCGUUGCAGCCCAGUCAAUAUCGCGGGACCCAAUCCUUU 293
...............(((........))).....(((((((....(.(((...(((((((....((((((((.......(((((.(((((.(....(((((((((.(((((.(.(((((((((((.(((.((((((.((....)).)))))).))).))))((...)).((.((......(((....(((....)))....)))....))..))))))))).)..)))))))...))))))).).))))))))))))))))))))))))).....))).)...)))))))...
...............(((........))).....(((((((....(.(((...(.(.((.....((((((((.......(((((.(((((.(....(((((((((.(((((.(.(((((((((((.(((.((((((.((....)).)))))).))).))))((...)).((.((......(((....(((....)))....)))....))..))))))))).)..)))))))...))))))).).)))))))))))))))))))).)..).....))).)...)))))))...
CCGAAAGGCUAGGACAAUGGCGGGCUAGUGAAUUGUGUCAGAUCCGGAAGGAAGCAGCACUAAGCAAGUGCCGCCAUGUGUCUGAUUGAAUAA 93
......((.(.(((((.((((((.((.((.....((((....(((....)))....))))...)).))..))))))))..))).).)...)..
......((.(.(((((.(((((((((.((.....((((....(((....)))....))))...)).))).))))))))..))).).)...)..
GACAAAUGUUUUCAGGUCUUCUAAAUCUGUUUUGGAGAAAUCCGUUUGUUUCCA 54
(((((((............((((((.....)))))).......)))))))....
(((((((.....(((((.......)))))....(((....))))))))))....
UUAAGUGACGAUAGCCUAGGAGAUACACCUGUUCCCAUGCCGAACACAGAAGUUAAGCCCUAGUACGCCUGAUGUAGUUGGGGGUUGCCCCCUGUUAGAUACGGUAGUCGCUUAGC 116
((((((((.....(.(((((......((((((.............))))..)).....)))))..).((..(....((.(((((...))))).))....)..))...)))))))).
((((((((.....(.(((((......((((((.............))))..)).....)))))..).((..(....((.((((.....)))).))....)..))...)))))))).
GCCGCGAUAAGAAUAACAUCUGAACGAGUUAGGACCGGAAGGUAGCAGCUAUAAGGAAAAGUGUUCUGUAUUGCGGU 77
(((((((((.(((((...(((.....(((....(((....)))....)))....)))....)))))))..)))))))
.((((((((.(((((...(((.....(((....(((....)))....)))....)))....)))))))..)))))).
GGAGAUCGGCGCGGACGGAGUCCUCGCCAACCUGGUCAGGGCCGAGAGGCAGCAGCCACAACGAGAUCACCUCUGGGUCGUCUGCCGGUCUCCACCUCAUUUU 103
((......(.((((.(((((..((((......((((....(((....)))....))))...)))).....)))))..)))).).....)).............
(((((((.(.((((.(((((..((((......((((....(((....)))....))))...)))).....)))))..)))).)...)))))))..........
GACUCGGACCCAUGCGGCCGCGACGCCUAAAUCUGGUCAGGACCGGAAGGGAGCAGCCACACGGGAUGCUCGUGACAGGCGUGGACUCCGGGUCACC 97
((((((((.((((((.(.((((((((((.....((((.....((....)).....))))...))).)).))))).)..))))))..))))))))...
(.((.((..((((((.(.((((((((((.....((((.....((....)).....))))...))).)).))))).)..))))))..)).)).)....
AGCCCCCGGUCCAGCGCGGCGGGCCAGGCGUGAACCGGGUCAGGUCCGGAAGGAAGCAGCCCUAAGCGCCUCGGUCCGGGCGCCGCUGGGAAGCCGGGGGCGCUU 105
.(((((((((((((((((.(((((.((((((.....((((....(((....)))....))))...))))))..)))))..)).)))))))...))))))))....
.(((((((((((((((((.((((((((((((.....((((....(((....)))....))))...)))))).))))))..)).)))))))...))))))))....
GUUGGGGGCCUUUUAAGAGAAGGAACCUGCGAAUCGGGUCAGGACUGGAAGGUAGCAGCCCUAAGGAGAGUUUUCUUUUGCUAAAAGAAUGUUCUCCAACUUAC 104
..((((((.((((((.(((.(((...((.(.....((((....(((....)))....))))...).))...))).)))...))))))....)).))))......
..((((((.(((((..(((.(((...((.(.....((((....(((....)))....))))...).))...))).)))....)))))....)).))))......
AUGGUCAGGUAGGGUGGAGGGUCUCGCCAGCCCUUAUACCCACAUGGCGCAACGUGGGCACCAGUAACUCCUAUGCUAUAAUACCUGCUCUUCGAGAUCCCAGUCUAACUAUGAUCAUCGCCCGACGGGGCGAGAUAGUCGUGGGUUCCCUUUCUGGAGGGAGAGGGAAUUCCACGUUGACCGGGGGAACCGGCCAGGCCCGGAAGGGAGCAACCGUGCCCGGCUAUCCGCGUUCGUCGGUCUCCGAUAGGAGGAAGACUGGGGGUAAAUCUCGGGGAGUAAGGGUUAUGGCAUAGGGGAGCUGACCAU 309
((((((((.(..((((((((((.......))))))...(((((..........))))))))).....(((((((((((((((...(((((((((((.(((((((((..((....(.((((.(((((((.(((.(((((.((((((((((((((((....))))))))))).))))).)..(((.((....(((.....(((....))).....)))..))))).))))))).).))))))....)))))...)).)))))))))......)))))))))))..).))))))))))))))).))))))))
((((((((.(..((((((((((.......))))))...(((((..........))))))))).....(((((((((((((((...(((((((((((.(((((((((..(..(..(.((((.(((((((.(((.(((((.((((((((((((((((....))))))))))).))))).)..((((.(....(((.....(((....))).....)))..))))).))))))).).))))))....)))).)).)..)))))))))......)))))))))))..).))))))))))))))).))))))))
UUUGGUCAUCAUUGCGAUGGAGAUACACCUGUUCCCAUGUCGAACACAGAAGUUAAGUCCAUCUACGGCGGAAGUACUUGGGGGUUGCCCCCUGGGAGAUAGGCGAGUGGCCAAGU 116
((((((((.....(.((((((.....((((((.............))))..))....))))))..).((..(....((.(((((...))))).))....)..))...)))))))).
((((((((.....(.((((((.....((((((.............))))..))....))))))..).((.(.....(..(((((...))))).).....).).)...)))))))).
GGAGCAACAUUUACUCGUGAAGUGGGUCAGGGGAGGAAUCCAGCAGCCCUAAGCGAUGCUAAAUGUGUGCUCUUUUU 77
((((((.(((((..((((.....((((....(((....)))....))))...))))....)))))))..))))....
((((((.(((((((.(((.....((((....(((....)))....))))...)))..).))))))))..))))....
UUUGCCGUGCUAAGCGGGGAGGUAGCGGUGCCCUAUACUCGCAAUCCGCUCUAGCGAGGCCGAAUCCCUUCUCGAGGUUAUGUUGCUGUAAGGCCUGCCUUAAGUAAGUGGUGUUGACGUUUGGGUCCUGCGCAACGGGACCCCGUGAACCUUGUCAGGUCCGGAAGGAAGCAGCAAUAAGCGGGUCUUCUCGUGUGCCGCAGGAGUGCCUGAACCGAGCUAACUGCUUAAGUAACGCUUAUGGUACGUAAUCGACAGAAGGUGCACGG 269
....((((((...((((((.(.(...).).))))...(((((...........)))))))......((((((...((((((..((.((((((...(((.((((((.((((((......((((((((((((((((.(((((.(((((.....((((....(((....)))....))))...)))))...)))))))...))))))...))))))))...))).))))))))))))...))))).))).))))))...)))))).))))))
....((((((...((((((.(.(...).).))))...(((((...........)))))))......((((((...((((((..((((..(..(..(((.((((((.((((((......((((((((((((((((.((((((((.((.....((((....(((....)))....))))...))))))...))))))...))))))...))))))))...))).)))))))))))).)..)...)))).))))))...)))))).))))))
....((((((....(((((.(.(...).).))))...((.............)).)..........(((..(.(.((((((..(((((((((...(((..(.((..((((((......((((((((((((((((.(((((.(((((.....((((....(((....)))....))))...)))))...)))))))...))))))...))))))))...))).)))..)).))))...))))))))).))))))..).).))).))))))
CGUUUGGGUCCUGCGCAACGGGACCCCGUGAACCUUGUCAGGUCCGGAAGGAAGCAGCAAUAAGCGGGUCUUCUCGUGUGCCGCAGGAGUGCCUGAACCGAGC 103
.((((((((((((((((.(((((.(((((.....((((....(((....)))....))))...)))))...)))))))...))))))...)))))))).....
.((((((((((((((((.((((((((.((.....((((....(((....)))....))))...))))))...))))))...))))))...)))))))).....
CCCUCACGCGGCGCUAUCUGACUGAACUCCCCCAGGGCCGGAAGGCAGCAAGGGUAGGUCGGCUCUGGCGGGUGCGUGGGGG 82
(((((((((..(((((.((((((.....(((.....(((....))).....)))..))))))...))))).)..))))))))
(((.(.(((..(((((.((((((.....(((.....(((....))).....)))..))))))...))))).))).).)))..
UAGUUUGCCUCCGCGCGGCGUUACCCGGGUGAACUCCCCCAGGUUAGGAAUAAAGCAAGGGUAGCUCGGCUCUGGCGGGUGUGCGGGGGUCUUGCGGGCUCCGUU 105
..(.((..((((((((..(((((.((((((.....(((.....(((....))).....)))..))))))...))))).)..)))))))........)).).....
..(...((((((((((..(((((.((((((.....(((.....(((....))).....)))..))))))...))))).)..)))))))))..)............
GGGAGGUUGGUGGUGGACGAGCCACUCGCCAACCGGGUCAGGUCCGGAAGGAAGCAGCCCUAACGAGCCAGGCACGGGUCGCCGUGCCAGCCUCCCACCUUUU 103
(((.(...((((((((.((.(((.((((......((((....(((....)))....))))...))))...))).))..))))))).)...).)))........
(((.(.(..(((((((.((.(((.((((......((((....(((....)))....))))...))))...))).))..)))))))...).).)))........
2.789473684210526
2
6
19
#+end_example

402
* compare loop contents

#+begin_src python :results output
from RNA import b2Shapiro, db_from_plist, PS_rna_plot
from re import findall
from utils import MCC_bench
from numpy import array
import numpy as np
import matplotlib.pyplot as plt
from utils_analysis import read_ct, get_bp_list, dotb_from_ct
from math import isnan

plt.rcParams["font.family"] = "serif"
plt.rcParams["font.size"] = 12
plt.rcParams["figure.figsize"] = 8, 5

def read_true_struct(infile="./kinetic_bench/benchmark_cleaned_red_all_length.csv"):
    results = {}
    for l in open(infile):
        seq, struct, name = l.strip().split(",")
        if "<" not in struct:
            results[seq] = struct
    return results

def read_csv(infile):
    # results = []
    results = {}
    first = True
    for l in open(infile):
        if not first:
            seq, len_seq, struct, nrj, nb_bp, pvv, sens, name = l.strip().split(",")
            if struct != "Na":
                results[seq] = (int(len_seq), struct, float(nrj), int(nb_bp), float(pvv), float(sens))
        else:
            first = False
    return results

def get_loop_content(struct):
    shap = b2Shapiro(struct)
    interior = findall(r"I\d+", shap)
    stack = findall(r"S\d+", shap)
    multi = findall(r"M\d+", shap)
    hairpin = findall(r"H\d+", shap)
    bulge = findall(r"B\d+", shap)
    ext_loop = findall(r"E\d+", shap)
    interior_nb = sum(int(el[1:]) for el in interior)
    stack_nb    = sum(int(el[1:]) for el in stack)
    multi_nb    = sum(int(el[1:]) for el in multi)
    hairpin_nb  = sum(int(el[1:]) for el in hairpin)
    ext_loop_nb = sum(int(el[1:]) for el in ext_loop)
    bulge_nb = sum(int(el[1:]) for el in bulge)
    tot_ = interior_nb +stack_nb +multi_nb +hairpin_nb +ext_loop_nb+bulge_nb
    if tot_ > 0:
        return float(interior_nb)/tot_, float(stack_nb)/tot_, float(multi_nb)/tot_, float(hairpin_nb)/tot_, float(ext_loop_nb)/tot_, float(bulge_nb)/tot_
    else:
        return 0.0, 0.0, 0.0, 0.0, 0.0, 0.0


fft_pred = read_csv("./kinetic_bench/results_fft_all_length_100n_50ms_best_nrj_scores.csv")
line_pred = read_csv("./test_data/results_linear_scores.csv")
cont_pred = read_csv("./test_data/results_context_scores.csv")
mx_pred = read_csv("./test_data/results_mxfold_scores.csv")
vrna_pred = read_csv("./test_data/results_mfe_scores.csv")
targets = read_true_struct()

results = []
struct_list = []
fft_all_v, mfe_all_v, cont_all_v, line_all_v, mx_all_v = [], [], [], [], []
with open("./scratch/fft_loop_content.csv", "w") as out:
    out.write(f"pcc_fft,int_l,sta_l,mul_l,hai_l\n")
    for seq in targets:
        if seq in fft_pred and seq in vrna_pred and seq in cont_pred and seq in line_pred and seq in mx_pred:
            len_seq, fft_st, fft_nrj, fft_nbp, fft_pvv, fft_sens = fft_pred[seq]
            len_seq, mfe_st, mfe_nrj, mfe_nbp, mfe_pvv, mfe_sens = vrna_pred[seq]
            len_seq, cont_st, cont_nrj, cont_nbp, cont_pvv, cont_sens = cont_pred[seq]
            len_seq, line_st, line_nrj, line_nbp, line_pvv, line_sens = line_pred[seq]
            len_seq, mx_st, mx_nrj, mx_nbp, mx_pvv, mx_sens = mx_pred[seq]
            save_fft, save_mfe, save_cont, save_line, save_mx = fft_pvv, mfe_pvv, cont_pvv, line_pvv, mx_pvv

            true_struct = targets[seq]
            struct_list += [true_struct]
            int_l, sta_l, mul_l, hai_l, ext_l, bul_l = get_loop_content(true_struct)
            results += [[int_l, sta_l, mul_l, hai_l, bul_l, ext_l]]

            fft_all_v += [save_fft]
            mfe_all_v += [save_mfe]
            cont_all_v += [save_cont]
            line_all_v += [save_line]
            mx_all_v += [save_mx]


results = array(results)
results -= results.mean(axis=0)
cov = np.cov(results.T)/results.shape[0]
V, W = np.linalg.eig(cov)
idx = V.argsort()[::-1]
W = W[:, idx]
fig = plt.figure(1)
fig.subplots_adjust(left=0.05, bottom=0.05, right=0.99, top=0.95, wspace=0, hspace=0.05)
fig.tight_layout()

fft_f = fig.add_subplot(121)
mfe_f = fig.add_subplot(122)
# cont_f = fig.add_subplot(223)
# mx_f = fig.add_subplot(224)
fft_f.set_aspect("equal", adjustable="box")
fft_f.grid(True, color="grey",linestyle="--", linewidth=0.2)
mfe_f.set_aspect("equal", adjustable="box")
mfe_f.grid(True, color="grey",linestyle="--", linewidth=0.2)

# cont_f.set_aspect("equal", adjustable="box")
# cont_f.grid(True, color="grey",linestyle="--", linewidth=0.2)
# mx_f.set_aspect("equal", adjustable="box")
# mx_f.grid(True, color="grey",linestyle="--", linewidth=0.2)

wrong_fft = [i for i, el in enumerate(fft_all_v) if el <= 0]
wrong_mfe = [i for i, el in enumerate(mfe_all_v) if el <= 0]
wrong_cont = [i for i, el in enumerate(cont_all_v) if el <= 0]
# wrong_line = [i for i, el in enumerate(line_all_v) if el <= 10]
wrong_mx = [i for i, el in enumerate(mx_all_v) if el <= 0]

proj = results.dot(W)
for el in np.where(proj[:, 1] < -0.5)[0]:
    print(struct_list[el])

# results.dot(W)[results.dot(W[:,0]) > 1] , results.dot(W[:,1])[results.dot(W[:,1]) > 1]
fft_f.scatter(results.dot(W[:,0]) , results.dot(W[:,1]) , edgecolor="", color="grey", alpha=0.5, s=10)
fft_f.scatter(results[wrong_fft, :].dot(W[:,0]) , results[wrong_fft, :].dot(W[:,1]) , edgecolor="", color="deepskyblue", alpha=0.5, s=14)
fft_f.arrow(0, 0, W[0,0]*0.27, W[0,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
fft_f.annotate("I", xy=(W[0,0]*0.27+0.02, W[0,1]*0.27+0.02), size=12)
fft_f.arrow(0, 0, W[1,0]*0.27, W[1,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
fft_f.annotate("S", xy=(W[1,0]*0.27-0.05, W[1,1]*0.27-0.02), size=12)
fft_f.arrow(0, 0, W[2,0]*0.27, W[2,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
fft_f.annotate("M", xy=(W[2,0]*0.27-0.01, W[2,1]*0.27+0.02), size=12)
fft_f.arrow(0, 0, W[3,0]*0.27, W[3,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
fft_f.annotate("H", xy=(W[3,0]*0.27-0.02, W[3,1]*0.27+0.03), size=12)
fft_f.arrow(0, 0, W[4,0]*0.27, W[4,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
fft_f.annotate("B", xy=(W[4,0]*0.27-0.00, W[4,1]*0.27+0.03), size=12)
fft_f.arrow(0, 0, W[5,0]*0.27, W[5,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
fft_f.annotate("E", xy=(W[5,0]*0.27-0.05, W[5,1]*0.27+0.00), size=12)
# fft_f.tick_params(axis="x", labelbottom=False, size=0)
fft_f.set_title(f"RAFFT")

mfe_f.scatter(results.dot(W[:,0]) , results.dot(W[:,1]) , edgecolor="", color="grey", alpha=0.5, s=10)
mfe_f.scatter(results[wrong_mfe, :].dot(W[:,0]) , results[wrong_mfe, :].dot(W[:,1]) , edgecolor="", color="orangered", alpha=0.5, s=14)
mfe_f.arrow(0, 0, W[0,0]*0.27, W[0,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
mfe_f.annotate("I", xy=(W[0,0]*0.27+0.02, W[0,1]*0.27+0.02), size=12)
mfe_f.arrow(0, 0, W[1,0]*0.27, W[1,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
mfe_f.annotate("S", xy=(W[1,0]*0.27-0.05, W[1,1]*0.27-0.02), size=12)
mfe_f.arrow(0, 0, W[2,0]*0.27, W[2,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
mfe_f.annotate("M", xy=(W[2,0]*0.27-0.01, W[2,1]*0.27+0.02), size=12)
mfe_f.arrow(0, 0, W[3,0]*0.27, W[3,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
mfe_f.annotate("H", xy=(W[3,0]*0.27-0.02, W[3,1]*0.27+0.03), size=12)
mfe_f.arrow(0, 0, W[4,0]*0.27, W[4,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
mfe_f.annotate("B", xy=(W[4,0]*0.27-0.00, W[4,1]*0.27+0.03), size=12)
mfe_f.arrow(0, 0, W[5,0]*0.27, W[5,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
mfe_f.annotate("E", xy=(W[5,0]*0.27-0.05, W[5,1]*0.27+0.00), size=12)
mfe_f.tick_params(axis="y", labelleft=False, size=0)
# mfe_f.tick_params(axis="x", labelbottom=False, size=0)
mfe_f.set_title(f"MFE")

# cont_f.scatter(results.dot(W[:,0]) , results.dot(W[:,1]) , edgecolor="", color="grey", alpha=0.5, s=10)
# cont_f.scatter(results[wrong_cont, :].dot(W[:,0]) , results[wrong_cont, :].dot(W[:,1]) , edgecolor="", color="blueviolet", alpha=0.5, s=14)
# cont_f.arrow(0, 0, W[0,0]*0.27, W[0,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
# cont_f.annotate("I", xy=(W[0,0]*0.27-0.02, W[0,1]*0.27+0.02), size=12)
# cont_f.arrow(0, 0, W[1,0]*0.27, W[1,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
# cont_f.annotate("S", xy=(W[1,0]*0.27-0.05, W[1,1]*0.27-0.02), size=12)
# cont_f.arrow(0, 0, W[2,0]*0.27, W[2,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
# cont_f.annotate("M", xy=(W[2,0]*0.27-0.01, W[2,1]*0.27+0.02), size=12)
# cont_f.arrow(0, 0, W[3,0]*0.27, W[3,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
# cont_f.annotate("H", xy=(W[3,0]*0.27-0.02, W[3,1]*0.27+0.03), size=12)
# cont_f.arrow(0, 0, W[4,0]*0.27, W[4,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
# cont_f.annotate("B", xy=(W[4,0]*0.27-0.00, W[4,1]*0.27+0.03), size=12)
# cont_f.arrow(0, 0, W[5,0]*0.27, W[5,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
# cont_f.annotate("E", xy=(W[5,0]*0.27-0.05, W[5,1]*0.27+0.00), size=12)
# cont_f.set_title(f"ContextFold")

# mx_f.scatter(results.dot(W[:,0]) , results.dot(W[:,1]) , edgecolor="", color="grey", alpha=0.5, s=10)
# mx_f.scatter(results[wrong_mx, :].dot(W[:,0]) , results[wrong_mx, :].dot(W[:,1]) , edgecolor="", color="gold", s=14)
# mx_f.arrow(0, 0, W[0,0]*0.27, W[0,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
# mx_f.annotate("I", xy=(W[0,0]*0.27-0.02, W[0,1]*0.27+0.02), size=12)
# mx_f.arrow(0, 0, W[1,0]*0.27, W[1,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
# mx_f.annotate("S", xy=(W[1,0]*0.27-0.05, W[1,1]*0.27-0.02), size=12)
# mx_f.arrow(0, 0, W[2,0]*0.27, W[2,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
# mx_f.annotate("M", xy=(W[2,0]*0.27-0.01, W[2,1]*0.27+0.02), size=12)
# mx_f.arrow(0, 0, W[3,0]*0.27, W[3,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
# mx_f.annotate("H", xy=(W[3,0]*0.27-0.02, W[3,1]*0.27+0.03), size=12)
# mx_f.arrow(0, 0, W[4,0]*0.27, W[4,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
# mx_f.annotate("B", xy=(W[4,0]*0.27-0.00, W[4,1]*0.27+0.03), size=12)
# mx_f.arrow(0, 0, W[5,0]*0.27, W[5,1]*0.27, width = 0.002, facecolor="black", head_width = 0.02)
# mx_f.annotate("E", xy=(W[5,0]*0.27-0.05, W[5,1]*0.27+0.00), size=12)
# mx_f.tick_params(axis="y", labelleft=False, size=0)
# mx_f.set_title(f"Mxfold")

plt.savefig("img/comp_fails.png", dpi=300)
plt.show()
#+end_src

#+RESULTS:
#+begin_example
.(((......)))....................(.((....)))..........................((((((...((...((((.........))))...))))))))..........(.(((((..........))))).).....((.......((((....)))).....))................................................((((........))))...............................................
..............................................................................(((.((...(..(((((((....)))))))..)...)))))...(...)...........
......(((((((.(.(...).).))))....(((((...........))))))))...................................................................................(.....((((....(((....)))....))))...)
..............................................................................(((.((..(.((((.((((....)))).)))).).)))))...(...)...........
..(.(((....(((......)))....))).)................................
................................................................................(.((...(.((.(((((....))))).)).)...))).....(...)............
......(((((((((((.....)))))))....((((.(..........).))))))))...............................................................................................
....................(((((((((.(...).)).)))))))................(((..(..(..(((((.....))))).......)..)..)))................
.....(((.....(((....))).....))).................................
((((.....((((....(((....)))....))))..)))).................................
............(((((((..........)))))))...............................................................................
.....................(...).((((((.....((((....(((....)))....)))).))))))...........................
................................................................................(.((...(.((.(((((....))))).)).)...))).....(...)..........
...(.(((......(((....(((.....)))....)))....))).)...........................................
..............................((((....(((....)))....))))
......(((((((.(.(...).).))))....(((((...........))))))))...................................................................................(.....((((....(((....)))....))))...)
.....(((.....(((....))).....))).................................
#+end_example
#+begin_example
* compare loop distribution
#+begin_src python :results output
from RNA import b2Shapiro, db_from_plist, PS_rna_plot
from re import findall
from utils import MCC_bench
from numpy import array
import numpy as np
import matplotlib.pyplot as plt
from utils_analysis import read_ct, get_bp_list, dotb_from_ct
from math import isnan

plt.rcParams["font.family"] = "serif"
plt.rcParams["font.size"] = 10
plt.rcParams["figure.figsize"] = 12, 4.0

def read_true_struct(infile="./kinetic_bench/benchmark_cleaned_red_all_length.csv"):
    results = {}
    for l in open(infile):
        seq, struct, name = l.strip().split(",")
        results[seq] = struct
    return results

def read_csv(infile):
    # results = []
    results = {}
    first = True
    for l in open(infile):
        if not first:
            seq, len_seq, struct, nrj, nb_bp, pvv, sens, name = l.strip().split(",")
            if struct != "Na":
                results[seq] = (int(len_seq), struct, float(nrj), int(nb_bp), float(pvv), float(sens))
        else:
            first = False
    return results

def get_loop_content(struct):
    shap = b2Shapiro(struct)
    interior = findall(r"I\d+", shap)
    stack = findall(r"S\d+", shap)
    multi = findall(r"M\d+", shap)
    hairpin = findall(r"H\d+", shap)
    ext_loop = findall(r"E\d+", shap)
    bulge = findall(r"B\d+", shap)
    interior_nb = sum(int(el[1:]) for el in interior)
    stack_nb    = sum(int(el[1:]) for el in stack)
    multi_nb    = sum(int(el[1:]) for el in multi)
    hairpin_nb  = sum(int(el[1:]) for el in hairpin)
    ext_loop_nb = sum(int(el[1:]) for el in ext_loop)
    bulge_nb  = sum(int(el[1:]) for el in bulge)
    tot_ = interior_nb +stack_nb +multi_nb +hairpin_nb +ext_loop_nb+bulge_nb
    try:
        return float(interior_nb)/tot_, float(stack_nb)/tot_, float(multi_nb)/tot_, float(hairpin_nb)/tot_, float(ext_loop_nb)/tot_, float(bulge_nb)/tot_
    except:
        return 0.0, 0.0, 0.0, 0.0, 0.0, 0.0

    
fft_pred = read_csv("./kinetic_bench/results_fft_all_length_100n_50ms_best_nrj_scores.csv")
vrna_mfe = read_csv("./test_data/results_mfe_scores.csv")
mx_pred = read_csv("./test_data/results_mxfold_scores.csv")
targets = read_true_struct()

results_fft, results_mfe, results_mx = [], [], []
with open("./scratch/fft_loop_content.csv", "w") as out:
    out.write(f"pcc_fft,int_l,sta_l,mul_l,hai_l\n")
    for seq in targets:
        if seq in mx_pred:
            len_seq, fft_st, fft_nrj, fft_nbp, fft_pvv, fft_sens = fft_pred[seq]
            len_seq, mfe_st, mfe_nrj, mfe_nbp, mfe_pvv, mfe_sens = vrna_mfe[seq]
            len_seq, mx_st, mx_nrj, mx_nbp, mx_pvv, mx_sens = mx_pred[seq]
            true_struct = targets[seq]
            int_l, sta_l, mul_l, hai_l, ext_l, bul_l = get_loop_content(mfe_st)
            results_mfe += [[int_l, sta_l, mul_l, hai_l, bul_l, ext_l]]
            int_l, sta_l, mul_l, hai_l, ext_l, bul_l = get_loop_content(fft_st)
            results_fft += [[int_l, sta_l, mul_l, hai_l, bul_l, ext_l]]
            int_l, sta_l, mul_l, hai_l, ext_l, bul_l = get_loop_content(mx_st)
            results_mx += [[int_l, sta_l, mul_l, hai_l, bul_l, ext_l]]


results_fft = array(results_fft)
results_fft -= results_fft.mean(axis=0)
cov_fft = np.cov(results_fft.T)/results_fft.shape[0]
V_fft, W_fft = np.linalg.eig(cov_fft)
idx_fft = V_fft.argsort()[::-1]
W_fft = W_fft[:, idx_fft]

results_mfe = array(results_mfe)
results_mfe -= results_mfe.mean(axis=0)
cov_mfe = np.cov(results_mfe.T)/results_mfe.shape[0]
V_mfe, W_mfe = np.linalg.eig(cov_mfe)
idx_mfe = V_mfe.argsort()[::-1]
W_mfe = W_mfe[:, idx_mfe]

results_mx = array(results_mx)
results_mx -= results_mx.mean(axis=0)
cov_mx = np.cov(results_mx.T)/results_mx.shape[0]
V_mx, W_mx = np.linalg.eig(cov_mx)
idx_mx = V_mx.argsort()[::-1]
W_mx = W_mx[:, idx_mx]

fig = plt.figure(1)
fig.subplots_adjust(left=0.05, bottom=0.1, right=0.99, top=0.90, wspace=0.12, hspace=0.1)
fig.tight_layout()

fft_f = fig.add_subplot(131)
mfe_f = fig.add_subplot(132)
mx_f = fig.add_subplot(133)
fft_f.set_aspect("equal", adjustable="box")
fft_f.grid(True, color="grey",linestyle="--", linewidth=0.2)
fft_f.set_xlim([-0.4, 0.4]); fft_f.set_ylim([-0.4, 0.3])
mfe_f.set_aspect("equal", adjustable="box")
mfe_f.grid(True, color="grey",linestyle="--", linewidth=0.2)
mfe_f.set_xlim([-0.4, 0.4]); mfe_f.set_ylim([-0.4, 0.3])
mx_f.set_aspect("equal", adjustable="box")
mx_f.grid(True, color="grey",linestyle="--", linewidth=0.2)
mx_f.set_xlim([-0.4, 0.4]); mx_f.set_ylim([-0.4, 0.3])

fft_f.scatter(results_fft.dot(W_fft[:,0]) , results_fft.dot(W_fft[:,1]) , edgecolor="", color="grey", alpha=0.5, s=8)
fft_f.arrow(0, 0, W_fft[0,0]*0.3, W_fft[0,1]*0.3, width = 0.002, facecolor="black", head_width = 0.02)
fft_f.annotate("I", xy=(W_fft[0,0]*0.3-0.02, W_fft[0,1]*0.3+0.02), size=12)
fft_f.arrow(0, 0, W_fft[1,0]*0.3, W_fft[1,1]*0.3, width = 0.002, facecolor="black", head_width = 0.02)
fft_f.annotate("S", xy=(W_fft[1,0]*0.3-0.00, W_fft[1,1]*0.3+0.04), size=12)
fft_f.arrow(0, 0, W_fft[2,0]*0.3, W_fft[2,1]*0.3, width = 0.002, facecolor="black", head_width = 0.02)
fft_f.annotate("M", xy=(W_fft[2,0]*0.3-0.01, W_fft[2,1]*0.3+0.02), size=12)
fft_f.arrow(0, 0, W_fft[3,0]*0.3, W_fft[3,1]*0.3, width = 0.002, facecolor="black", head_width = 0.02)
fft_f.annotate("H", xy=(W_fft[3,0]*0.3-0.02, W_fft[3,1]*0.3+0.03), size=12)
fft_f.arrow(0, 0, W_fft[4,0]*0.3, W_fft[4,1]*0.3, width = 0.002, facecolor="black", head_width = 0.02)
fft_f.annotate("B", xy=(W_fft[4,0]*0.3+0.02, W_fft[4,1]*0.3+0.03), size=12)
fft_f.arrow(0, 0, W_fft[5,0]*0.3, W_fft[5,1]*0.3, width = 0.002, facecolor="black", head_width = 0.02)
fft_f.annotate("E", xy=(W_fft[5,0]*0.3+0.01, W_fft[5,1]*0.3-0.03), size=12)
fft_f.set_title(f"RAFFT")

mfe_f.scatter(results_mfe.dot(W_mfe[:,0]) , results_mfe.dot(W_mfe[:,1]) , edgecolor="", color="grey", alpha=0.5, s=8)
mfe_f.arrow(0, 0, W_mfe[0,0]*0.3, W_mfe[0,1]*0.3, width = 0.002, facecolor="black", head_width = 0.02)
mfe_f.annotate("I", xy=(W_mfe[0,0]*0.3-0.02, W_mfe[0,1]*0.3+0.02), size=12)
mfe_f.arrow(0, 0, W_mfe[1,0]*0.3, W_mfe[1,1]*0.3, width = 0.002, facecolor="black", head_width = 0.02)
mfe_f.annotate("S", xy=(W_mfe[1,0]*0.3-0.04, W_mfe[1,1]*0.3+0.03), size=12)
mfe_f.arrow(0, 0, W_mfe[2,0]*0.3, W_mfe[2,1]*0.3, width = 0.002, facecolor="black", head_width = 0.02)
mfe_f.annotate("M", xy=(W_mfe[2,0]*0.3-0.01, W_mfe[2,1]*0.3+0.03), size=12)
mfe_f.arrow(0, 0, W_mfe[3,0]*0.3, W_mfe[3,1]*0.3, width = 0.002, facecolor="black", head_width = 0.02)
mfe_f.annotate("H", xy=(W_mfe[3,0]*0.3-0.02, W_mfe[3,1]*0.3+0.03), size=12)
mfe_f.arrow(0, 0, W_mfe[4,0]*0.3, W_mfe[4,1]*0.3, width = 0.002, facecolor="black", head_width = 0.02)
mfe_f.annotate("B", xy=(W_mfe[4,0]*0.3-0.06, W_mfe[4,1]*0.3+0.03), size=12)
mfe_f.arrow(0, 0, W_mfe[5,0]*0.3, W_mfe[5,1]*0.3, width = 0.002, facecolor="black", head_width = 0.02)
mfe_f.annotate("E", xy=(W_mfe[5,0]*0.3-0.02, W_mfe[5,1]*0.3-0.07), size=12)
mfe_f.tick_params(axis="y", labelleft=False, size=0)
mfe_f.set_title(f"MFE")

mx_f.scatter(results_mx.dot(W_mx[:,0]) , results_mx.dot(W_mx[:,1]) , edgecolor="", color="grey", alpha=0.5, s=8)
mx_f.arrow(0, 0, W_mx[0,0]*0.3, W_mx[0,1]*0.3, width = 0.002, facecolor="black", head_width = 0.02)
mx_f.annotate("I", xy=(W_mx[0,0]*0.3-0.02, W_mx[0,1]*0.3+0.02), size=12)
mx_f.arrow(0, 0, W_mx[1,0]*0.3, W_mx[1,1]*0.3, width = 0.002, facecolor="black", head_width = 0.02)
mx_f.annotate("S", xy=(W_mx[1,0]*0.3+0.02, W_mx[1,1]*0.3+0.03), size=12)
mx_f.arrow(0, 0, W_mx[2,0]*0.3, W_mx[2,1]*0.3, width = 0.002, facecolor="black", head_width = 0.02)
mx_f.annotate("M", xy=(W_mx[2,0]*0.3-0.03, W_mx[2,1]*0.3-0.07), size=12)
mx_f.arrow(0, 0, W_mx[3,0]*0.3, W_mx[3,1]*0.3, width = 0.002, facecolor="black", head_width = 0.02)
mx_f.annotate("H", xy=(W_mx[3,0]*0.3-0.02, W_mx[3,1]*0.3+0.03), size=12)
mx_f.arrow(0, 0, W_mx[4,0]*0.3, W_mx[4,1]*0.3, width = 0.002, facecolor="black", head_width = 0.02)
mx_f.annotate("B", xy=(W_mx[4,0]*0.3+0.02, W_mx[4,1]*0.3-0.04), size=12)
mx_f.arrow(0, 0, W_mx[5,0]*0.3, W_mx[5,1]*0.3, width = 0.002, facecolor="black", head_width = 0.02)
mx_f.annotate("E", xy=(W_mx[5,0]*0.3-0.02, W_mx[5,1]*0.3+0.04), size=12)
mx_f.tick_params(axis="y", labelleft=False, size=0)
mx_f.set_title(f"MXfold")

plt.savefig("img/content_predicted_data.png", dpi=300)
plt.show()
#+end_src

#+RESULTS:

* alignment

#+begin_src python :results output
from utils import prep_sequence, auto_cor, seq_conv
from scipy.signal import convolve
import matplotlib.pyplot as plt
from numpy import array

seq_x = "AAAACCCCAAAACCCCUUUUCCCUUUUUUCCCCCAAAA"
seq_y = "AAAACCCCAAAACCCCUUUUCCCUUUUUUCCCCCAAAA"
len_x, len_y = len(seq_x), len(seq_y)

eseq_x, cseq_x = prep_sequence(seq_x)
eseq_y, cseq_y = prep_sequence(seq_y)

conv_xx = array([c for _, c in auto_cor(eseq_x, cseq_x)])
conv_yy = array([c for _, c in auto_cor(eseq_y, cseq_y)])

conv_xy = [(i, c) for i, c in enumerate(convolve(conv_xx, conv_yy[::-1]))]

conv_xy_sim = array([c for _, c in auto_cor(eseq_x, eseq_y)])

pos, c = max(conv_xy, key=lambda el: el[1])

if pos < len_x:
    eseq_x = eseq_x[:, :pos+1]
    cseq_x = cseq_x[:, len_x-pos-1:]
    seq_x = seq_x[:pos+1]
else:
    eseq_x = eseq_x[:, pos-len_x+1:]
    cseq_x = cseq_x[:, :2*len_x-pos-1]
    seq_x = seq_x[pos-len_x+1:]

# figure, axis = plt.subplots(3, 1)
# axis[0].plot(conv_xx)
# axis[1].plot(conv_yy)
# axis[2].plot(conv_xy)

# plt.plot(conv_yx+conv_xy)
# plt.plot(conv_yx+conv_xy+conv_xy_sim)

# score_l = [(i, s) for i, s in enumerate(conv_yx+conv_xy+conv_xy_sim)]
# pos, max_s = max(score_l, key=lambda el: el[1])

# if pos < len_x:
#     eseq_x = eseq_x[:, :pos+1]
#     cseq_x = cseq_x[:, len_x-pos-1:]
#     seq_x = seq_x[:pos+1]
# else:
#     eseq_x = eseq_x[:, pos-len_x+1:]
#     cseq_x = cseq_x[:, :2*len_x-pos-1]
#     seq_x = seq_x[pos-len_x+1:]

# if pos < len_y:
#     eseq_y = eseq_y[:, :pos+1]
#     cseq_y = cseq_y[:, len_y-pos-1:]
#     seq_y = seq_y[:pos+1]
# else:
#     eseq_y = eseq_y[:, pos-len_y+1:]
#     cseq_y = cseq_y[:, :2*len_y-pos-1]
#     seq_y = seq_y[:, pos-len_y+1:]

# print(seq_x)
# print(seq_y)

plt.show()
#+end_src

#+RESULTS:

#+begin_src python :results output
from scipy.signal import convolve

a = list(range(10))
b = list(range(10))

import matplotlib.pyplot as plt

plt.plot(convolve(a, b[::-1]))
plt.show()
#+end_src

#+RESULTS:

#+begin_src python :results output
from utils import prep_sequence, auto_cor, seq_conv, dot_bracket
import matplotlib.pyplot as plt
from numpy import array
from scratch import recursive_struct

seq_x = "AAAGAAAAC"
seq_y = "ACCCCU"
len_x, len_y = len(seq_x), len(seq_y)

eseq_x, cseq_x = prep_sequence(seq_x)
eseq_y, cseq_y = prep_sequence(seq_y)
pos_x, pos_y = list(range(len_x)), list(range(len_y))

pair_x ,pair_y = recursive_struct(eseq_x, cseq_x, eseq_y, cseq_y, pos_x, pos_y, [], [], seq_x, seq_y)
struct_x = dot_bracket(pair_x, len_x)
struct_y = dot_bracket(pair_y, len_y)

print(seq_x)
print(struct_x)
print(seq_y)
print(struct_y)
#+end_src


#+begin_src python :results output

#+end_src
* test

#+begin_src python :results output
from utils import prep_sequence, auto_cor_test, seq_conv, auto_cor
from utils import read_fasta
from scipy.signal import convolve
from scipy.stats import pearsonr
from numpy.fft import fft, ifft
import matplotlib.pyplot as plt
from numpy import array, zeros

seq_x = "GCAGGGGACTCATCAACCAAAATGGTGGCGCCGGAGGGCGACCTTCGGATGCGAACCGGGTGAATTGCGGGAAACCTAAACCTCTGTTTTGAGGCACGGCGATCCGCAGCCAAGCCTGGCCGGGCTTTGGTGGCCAGGAAGGTTCAGAGACTAGCGGGGTGAGTCCCAACGATAATCCCCGCCTCGAGCGCCCGGCCTCCCTCGAATGCTTCGAGGCGGTCACGTCAAGCGGTCCGTCAACGACCGCCACGCAACCGTTTCGATCGTCGCAGGCGAGGATGAGATAGTCCAAGCCCCGTGGAAACGCGGGG"
seq_y = "CATTGAAATTTCTTTATGGTGATCAATACAAAAACATTATAACCAACATTAAACAAGTGCTTAGTGATTGGCGACACCTTCAAATTGCGGGAACTCCGTCCGATTCTAGTACGTCAATAACAGCCTCAAGTACCACTTCAGTTGAGAAATCTTCTGAAGGAACACAGGTAATTCCTGTTCCCAATCGGACTTCGTCCGCGAACCTATGGTTCGATGGTAACAAGCTTGAGGACATGGTGGAAATCCGCAGCCAAGCTCCTAAGTCCGAACGAAGTTGACAAGGATATGGAGAAGGTTCAGAGACTTAATGGGGGTGGGGCTGAAGGATCTGGTCAATCCTGATGAAGCCTTAAGATAAAGTCCAGCCTCTTTCGAAAGATTGAG"

eseq_x, cseq_x = prep_sequence(seq_x.replace("T", "U").replace("N", ""))
eseq_y, cseq_y = prep_sequence(seq_y.replace("T", "U").replace("N", ""))

cor_l_x = auto_cor(eseq_x, cseq_x, 1)
cor_l_y = auto_cor(eseq_y, cseq_y, 1)

figure, axis = plt.subplots(2, 1)
axis[0].plot([c+1 for i, c in cor_l_x])
axis[0].plot([c+1 for i, c in cor_l_y])
ft_x = fft([c for i, c in cor_l_x])[1:]
ft_y = fft([c for i, c in cor_l_y])[1:]


ft_x_ = zeros(max(len(seq_x), len(seq_y)))
ft_y_ = zeros(max(len(seq_x), len(seq_y)))

for i, el in enumerate(ft_x[:len(seq_x)]):
    ft_x_[i] = el
for i, el in enumerate(ft_y[:len(seq_y)]):
    ft_y_[i] = el

axis[1].plot(ft_x_)
axis[1].plot(ft_y_)

plt.show()
#+end_src

#+RESULTS:

#+begin_src python :results output
from utils import prep_sequence, auto_cor_test, seq_conv, auto_cor
from utils import read_fasta
from scipy.signal import convolve
from scipy.stats import pearsonr
from numpy.fft import fft, ifft
import matplotlib.pyplot as plt
from numpy import array, zeros

def read_true_struct(infile="./test_data/benchmark_data_full.csv"):
    results = {}
    for l in open(infile):
        seq, struct, name = l.strip().split(",")
        results[name] = seq
    return results

all_sp = []
nb = 0

# for name, seq in read_fasta("../evo_study/data/RF00028.fa").items():
for name, seq in read_true_struct().items():
    eseq, cseq = prep_sequence(seq.replace("T", "U").replace("N", "").replace("R", "").replace("B", "").replace("M", "").replace("D", ""))
    cor_l = auto_cor(eseq, cseq, 1)
    ft = fft([c for i, c in cor_l])[4:].real
    all_sp += [ft]
    nb += 1

max_len = max([len(sp) for sp in all_sp])
comb = zeros(max_len)
for sp in all_sp:
    for i, el in enumerate(sp):
        comb[i] += el/len(all_sp)
# for sp in all_sp:
#     plt.plot(sp, linewidth=0.8, alpha=0.5)
# plt.show()

figure, axis = plt.subplots(1, 1)
axis.plot(comb[:2000])

all_sp = []
# for name, seq in read_fasta("../evo_study/data/RF00028.fa").items():
for name, seq in read_fasta("./scratch/random_sequences.seq").items():
    eseq, cseq = prep_sequence(seq.replace("T", "U").replace("N", "").replace("R", "").replace("B", "").replace("M", "").replace("D", ""))
    cor_l = auto_cor(eseq, cseq, 1)
    ft = fft([c for i, c in cor_l])[4:].real
    all_sp += [ft]
    nb += 1

max_len = max([len(sp) for sp in all_sp])
comb = zeros(max_len)
for sp in all_sp:
    for i, el in enumerate(sp):
        comb[i] += el/len(all_sp)

axis.plot(comb[:2000])

all_sp = []
for name, seq in read_fasta("../evo_study/data/RF00028.fa").items():
    eseq, cseq = prep_sequence(seq.replace("T", "U").replace("N", "").replace("R", "").replace("B", "").replace("M", "").replace("D", ""))
    cor_l = auto_cor(eseq, cseq, 1)
    ft = fft([c for i, c in cor_l])[4:].real
    all_sp += [ft]
    nb += 1

max_len = max([len(sp) for sp in all_sp])
comb = zeros(max_len)
for sp in all_sp:
    for i, el in enumerate(sp):
        comb[i] += el/len(all_sp)

axis.plot(comb[:2000])
axis.grid(True, color="grey",linestyle="--", linewidth=0.2)
plt.show()
#+end_src

#+RESULTS:

#+begin_src python :results output
from utils import prep_sequence, auto_cor_test, seq_conv, auto_cor
from utils import read_fasta
from scipy.signal import convolve
from scipy.stats import pearsonr
from numpy.fft import fft, ifft
import matplotlib.pyplot as plt
from numpy import array, zeros

seq_x = "GCAGGGGACTCATCAACCAAAATGGTGGCGCCGGAGGGCGACCTTCGGATGCGAACCGGGTGAATTGCGGGAAACCTAAACCTCTGTTTTGAGGCACGGCGATCCGCAGCCAAGCCTGGCCGGGCTTTGGTGGCCAGGAAGGTTCAGAGACTAGCGGGGTGAGTCCCAACGATAATCCCCGCCTCGAGCGCCCGGCCTCCCTCGAATGCTTCGAGGCGGTCACGTCAAGCGGTCCGTCAACGACCGCCACGCAACCGTTTCGATCGTCGCAGGCGAGGATGAGATAGTCCAAGCCCCGTGGAAACGCGGGG"
seq_y = "CATTGAAATTTCTTTATGGTGATCAATACAAAAACATTATAACCAACATTAAACAAGTGCTTAGTGATTGGCGACACCTTCAAATTGCGGGAACTCCGTCCGATTCTAGTACGTCAATAACAGCCTCAAGTACCACTTCAGTTGAGAAATCTTCTGAAGGAACACAGGTAATTCCTGTTCCCAATCGGACTTCGTCCGCGAACCTATGGTTCGATGGTAACAAGCTTGAGGACATGGTGGAAATCCGCAGCCAAGCTCCTAAGTCCGAACGAAGTTGACAAGGATATGGAGAAGGTTCAGAGACTTAATGGGGGTGGGGCTGAAGGATCTGGTCAATCCTGATGAAGCCTTAAGATAAAGTCCAGCCTCTTTCGAAAGATTGAG"

eseq_x, cseq_x = prep_sequence(seq_x.replace("T", "U").replace("N", ""))
eseq_y, cseq_y = prep_sequence(seq_y.replace("T", "U").replace("N", ""))

cor_l_x = auto_cor(eseq_x, cseq_x, 1)
cor_l_y = auto_cor(eseq_y, cseq_y, 1)

ft_x = fft([c for i, c in cor_l_x])
ft_y = fft([c for i, c in cor_l_y])

cor_l_x_ = ifft(ft_x)
cor_l_y_ = ifft(ft_y)

figure, axis = plt.subplots(2, 1)
axis[0].plot([c for _, c in cor_l_x])
axis[1].plot(cor_l_x_)
plt.show()
#+end_src

#+RESULTS:


#+begin_src python :results output
from random import choices, choice
nuc = ['A', 'C', 'G', 'U']

with open("./scratch/random_sequences.seq", "w") as out:
    for i in range(1000):
        out.write(">{}\n{}\n".format(i, "".join(choices(nuc, k=choice(range(100, 3000))))))
#+end_src

#+RESULTS:

#+begin_src python :results output
from utils import prep_sequence, auto_cor_test, seq_conv, auto_cor
from utils import read_fasta
from scipy.signal import convolve
from scipy.stats import pearsonr
from numpy.fft import fft, ifft
import matplotlib.pyplot as plt
from numpy import array, zeros, corrcoef, dot
from numpy.random import RandomState

import scipy.cluster.hierarchy as hcl
from scipy.spatial.distance import squareform

def read_true_struct(infile="./test_data/benchmark_data_full.csv"):
    results = {}
    for l in open(infile):
        seq, struct, name = l.strip().split(",")
        results[name] = seq
    return results

all_sp = []
nb = 0
lname = []
# for name, seq in read_fasta("../evo_study/data/RF00028.fa").items():
for name, seq in read_true_struct().items():
    eseq, cseq = prep_sequence(seq.replace("T", "U").replace("N", "").replace("R", "").replace("B", "").replace("M", "").replace("D", ""))
    cor_l = auto_cor(eseq, cseq, 1)
    ft = fft([c for i, c in cor_l])[4:].real
    all_sp += [ft]
    nb += 1
    # lname += [name]
    lname += [str(len(seq))+"/"+name]
    if nb > 1000:
        break

max_len = max([len(sp) for sp in all_sp])

padded_sp = []
for sp in all_sp:
    comb = zeros(max_len)
    for i, el in enumerate(sp):
        comb[i] += el
    padded_sp += [comb]

dist_mat = zeros((len(padded_sp), len(padded_sp)))
for i, spi in enumerate(padded_sp):
    for j, spj in enumerate(padded_sp[i+1:], start=i+1):
        dist_mat[i,j] = corrcoef(spi, spj)[0][1]
        dist_mat[j,i] = dist_mat[i,j]

pairwise_distances = hcl.distance.pdist(dist_mat)
link = hcl.linkage(pairwise_distances, method="complete")
fig = plt.figure(1)
fig.subplots_adjust(left=0.05, bottom=0.1, right=0.70, top=0.90, wspace=0, hspace=0)
dend = fig.add_subplot(111)
hcl.dendrogram(link, labels=lname, orientation="left", ax=dend)
plt.savefig("img/test.png", dpi=300)
plt.show()
#+end_src

#+RESULTS:
* compare to kinfold
#+begin_src python :results output
from utils import paired_positions
import subprocess
import matplotlib.pyplot as plt
from matplotlib import rcParams, artist
from matplotlib.patches import Patch
from numpy import mean, std, median, linspace, arange
from scipy.stats import kde
from math import isnan
from RNA import fold_compound, bp_distance, read_parameter_file
plt.rcParams["font.family"] = "serif"
plt.rcParams["font.weight"] = "bold"
plt.rcParams["font.size"] = 6.7
plt.rcParams["figure.figsize"] = 8, 4


def read_true_struct(infile="./test_data/benchmark_data_full.csv"):
    results = {}
    for l in open(infile):
        seq, struct, name = l.strip().split(",")
        if "<" not in struct:
            results[seq] = (struct, name)
    return results


def read_csv(infile):
    results = {}
    first = True
    for l in open(infile):
        if not first:
            seq, len_seq, struct, nrj, nb_bp, pvv, sens, name = l.strip().split(",")
            if struct != "Na":
                if pvv == "nan":
                    pvv = 0.0
                results[seq] = (int(len_seq), struct, float(nrj), int(nb_bp), float(pvv), float(sens))
        else:
            first = False
    return results


fft_pred = read_csv("./test_data/results_fft_turner_2_scores.csv")
line_pred = read_csv("./test_data/results_linear_scores.csv")
kin_pred = read_csv("./test_data/results_kinfold_scores.csv")
cont_pred = read_csv("./test_data/results_context_scores.csv")
mx_pred = read_csv("./test_data/results_mxfold_scores.csv")
vrna_pred = read_csv("./test_data/results_mfe_scores.csv")
# vrna_pred = read_csv("./test_data/results_mfe_scores.csv")

true_str = read_true_struct()
fft_all_v, mfe_all_v, cont_all_v, line_all_v, mx_all_v = [], [], [], [], []
fft_to_plot, mfe_to_plot, cont_to_plot, line_to_plot, mx_to_plot = {}, {}, {}, {}, {}


nb = 0
nb_fft = 0
nb_only_fft, nb_only_mfe = 0, 0
nb_mfe = 0
nb_line = 0
tot = 0


with open("analysis.log", "w") as out:
    for seq, (struct, name) in true_str.items():
        seq_comp = fold_compound(seq)

        true_nb_bp = struct.count("(")
        true_nrj = seq_comp.eval_structure(struct)
        
        # if seq in fft_pred and seq in vrna_pred and seq in cont_pred and seq in line_pred and seq in mx_pred:
        if seq in fft_pred and seq in vrna_pred and seq in line_pred:
            if true_nrj >= 0:
                true_nrj
            else:
                len_seq, fft_st, fft_nrj, fft_nbp, fft_pvv, fft_sens = fft_pred[seq]
                len_seq, mfe_st, mfe_nrj, mfe_nbp, mfe_pvv, mfe_sens = vrna_pred[seq]
                len_seq, line_st, line_nrj, line_nbp, line_pvv, line_sens = line_pred[seq]
                len_seq, kin_st, kin_nrj, kin_nbp, kin_pvv, kin_sens = kin_pred[seq]

                # len_seq, cont_st, cont_nrj, cont_nbp, cont_pvv, cont_sens = cont_pred[seq]
                # len_seq, mx_st, mx_nrj, mx_nbp, mx_pvv, mx_sens = mx_pred[seq]
                # save_fft, save_mfe, save_cont, save_line, save_mx = fft_pvv, mfe_pvv, cont_pvv, line_pvv, mx_pvv

                save_fft, save_mfe, save_line = fft_nrj-mfe_nrj, true_nrj-mfe_nrj, line_nrj-mfe_nrj
                fft_all_v += [save_fft]
                mfe_all_v += [save_mfe]
                line_all_v += [save_line]
                # cont_all_v += [save_cont]
                # mx_all_v += [save_mx]
                if struct == fft_st:
                    nb_fft += 1
                if struct == mfe_st:
                    nb_mfe += 1
                if struct == line_st:
                    nb_line += 1
                if struct == fft_st and struct != mfe_st:
                    nb_only_fft += 1
                if struct != fft_st and struct == mfe_st:
                    nb_only_mfe += 1
                if struct != mfe_st and len_seq < 100:
                    out.write("-"*10+"\n")
                    out.write(f"LEN {len_seq} {name}\n")
                    out.write(f"FFT = {fft_pvv} MFE = {mfe_pvv}\n")
                    out.write(f"FFT = {fft_nrj:.2f} LIN = {line_nrj:.2f} TRUE = {true_nrj:.2f} MFE = {mfe_nrj:.2f}\n")
                    out.write(f"{seq}\n")
                    out.write(f"{fft_st} {fft_nbp}\n")
                    out.write(f"{mfe_st} {mfe_nbp}\n")
                    out.write(f"{struct} {true_nb_bp}\n")

                if len_seq in fft_to_plot:
                    fft_to_plot[len_seq] += [save_fft]
                    mfe_to_plot[len_seq] += [save_mfe]
                    line_to_plot[len_seq] += [save_line]
                    # cont_to_plot[len_seq] += [save_cont]
                    # mx_to_plot[len_seq] += [save_mx]
                else:
                    fft_to_plot[len_seq] = [save_fft]
                    mfe_to_plot[len_seq] = [save_mfe]
                    line_to_plot[len_seq] = [save_line]
                    # cont_to_plot[len_seq] = [save_cont]
                    # mx_to_plot[len_seq] = [save_mx]
                tot += 1

print("FFT", nb_fft, "MFE", nb_mfe, "LINE", nb_line, "ONLY FFT", nb_only_fft, "ONLY MFE", nb_only_mfe, "TOT", tot)
list_len = list(fft_to_plot.keys())
list_len.sort()
nb_el = len(list_len)

fft_mean = mean([mean(fft_to_plot[len_]) for len_ in list_len if len_ > 0])
mfe_mean = mean([mean(mfe_to_plot[len_]) for len_ in list_len if len_ > 0])
line_mean = mean([mean(line_to_plot[len_]) for len_ in list_len if len_ > 0])
# cont_mean = mean([mean(cont_to_plot[len_]) for len_ in list_len if len_ > 0])
# mx_mean = mean([mean(mx_to_plot[len_]) for len_ in list_len if len_ > 0])

slide_mean_fft = [mean([mean(fft_to_plot[l]) for l in list_len[max(0, i-20):min(nb_el, i+20)]]) for i, len_ in enumerate(list_len)]
slide_mean_mfe = [mean([mean(mfe_to_plot[l]) for l in list_len[max(0, i-20):min(nb_el, i+20)]]) for i, len_ in enumerate(list_len)]
slide_mean_line = [mean([mean(line_to_plot[l]) for l in list_len[max(0, i-20):min(nb_el, i+20)]]) for i, len_ in enumerate(list_len)]
# slide_mean_cont = [mean([mean(cont_to_plot[l]) for l in list_len[max(0, i-20):min(nb_el, i+20)]]) for i, len_ in enumerate(list_len)]
# slide_mean_mx = [mean([mean(mx_to_plot[l]) for l in list_len[max(0, i-20):min(nb_el, i+20)]]) for i, len_ in enumerate(list_len)]

bpros = dict(color="orange", linewidth=0.2)
fig = plt.figure(1)

left, width = 0.1, 0.65
bottom, height = 0.1, 0.85
spacing = 0.000
rect_scatter = [left, bottom, width, height]
rect_histy = [left + width + spacing, bottom, 0.2, height]
# fft_f = fig.add_subplot(111)
fft_f = fig.add_axes(rect_scatter)


ax_histy = fig.add_axes(rect_histy, sharey=fft_f)
# ax_histy.set_ylim([0, 100.0])
xs_scr = linspace(min(fft_all_v), max(fft_all_v), 50)
dens_fft_scr = kde.gaussian_kde(fft_all_v)
dens_mfe_scr = kde.gaussian_kde(mfe_all_v)
dens_line_scr = kde.gaussian_kde(line_all_v)
# dens_cont_scr = kde.gaussian_kde(cont_all_v)
# dens_mx_scr = kde.gaussian_kde(mx_all_v)
ax_histy.plot(dens_fft_scr(xs_scr), xs_scr, c="deepskyblue", linewidth=0.8)
ax_histy.plot(dens_mfe_scr(xs_scr), xs_scr, c="orangered", linewidth=0.8)
ax_histy.plot(dens_line_scr(xs_scr), xs_scr, c="green", linewidth=0.8)
# ax_histy.plot(dens_cont_scr(xs_scr), xs_scr, c="blueviolet", linewidth=0.8)
# ax_histy.plot(dens_mx_scr(xs_scr), xs_scr, c="darkslategrey", linewidth=0.8)
ax_histy.tick_params(axis="y", labelleft=False, size=0)
ax_histy.tick_params(axis="x", labelbottom=False, size=0)
ax_histy.grid(True, color="grey",linestyle="--", linewidth=0.2)

# fft_f.set_xlim([0, nb_el]); fft_f.set_ylim([0, 100.0])
fft_f.grid(True, color="grey",linestyle="--", linewidth=0.2)

fft_f.errorbar([i+0.0 for i in range(nb_el)], [mean(fft_to_plot[len_]) for len_ in list_len],
               yerr=[std(fft_to_plot[len_])/4 for len_ in list_len], elinewidth=0.8, fmt=".",
               linewidth=0.2, ms=3, c="skyblue", ecolor="deepskyblue", alpha=0.2)
fft_f.errorbar([i+0.0 for i in range(nb_el)], [mean(mfe_to_plot[len_]) for len_ in list_len],
               yerr=[std(mfe_to_plot[len_])/4 for len_ in list_len], elinewidth=0.8, fmt=".",
               linewidth=0.2, ms=3, c="coral", ecolor="orangered", alpha=0.2)
# fft_f.errorbar([i+0.0 for i in range(nb_el)], [mean(cont_to_plot[len_]) for len_ in list_len],
#                yerr=[std(cont_to_plot[len_])/4 for len_ in list_len], elinewidth=0.8, fmt=".",
#                linewidth=0.2, ms=3, c="blueviolet", ecolor="blueviolet", alpha=0.2)
fft_f.errorbar([i+0.0 for i in range(nb_el)], [mean(line_to_plot[len_]) for len_ in list_len],
               yerr=[std(line_to_plot[len_])/4 for len_ in list_len], elinewidth=0.8, fmt=".",
               linewidth=0.2, ms=3, c="palegreen", ecolor="palegreen", alpha=0.2)
# fft_f.errorbar([i+0.0 for i in range(nb_el)], [mean(mx_to_plot[len_]) for len_ in list_len],
#                yerr=[std(mx_to_plot[len_])/4 for len_ in list_len], elinewidth=0.8, fmt=".",
#                linewidth=0.2, ms=3, c="darkslategrey", ecolor="darkslategrey", alpha=0.2)

fft_f.scatter([i+0.0 for i in range(nb_el)], [mean(fft_to_plot[len_]) for len_ in list_len], c="deepskyblue", s=0.5)
fft_f.scatter([i+0.0 for i in range(nb_el)], [mean(mfe_to_plot[len_]) for len_ in list_len], c="orangered", s=0.5)
fft_f.scatter([i+0.0 for i in range(nb_el)], [mean(line_to_plot[len_]) for len_ in list_len], c="green", s=0.5)
# fft_f.scatter([i+0.0 for i in range(nb_el)], [mean(cont_to_plot[len_]) for len_ in list_len], c="blueviolet", s=0.5)
# fft_f.scatter([i+0.0 for i in range(nb_el)], [mean(mx_to_plot[len_]) for len_ in list_len], c="darkslategrey", s=0.5)

fft_f.plot(range(nb_el), slide_mean_fft, linestyle="--", c="deepskyblue", alpha = 0.8)
fft_f.plot(range(nb_el), slide_mean_mfe, linestyle="--", c="orangered", alpha = 0.8)
fft_f.plot(range(nb_el), slide_mean_line, linestyle="--", c="green", alpha = 0.8)
# fft_f.plot(range(nb_el), slide_mean_cont, linestyle="--", c="blueviolet", alpha = 0.8)
# fft_f.plot(range(nb_el), slide_mean_mx, linestyle="--", c="darkslategrey", alpha = 0.8)

fft_l = Patch(color="skyblue", label="FFT")
mfe_l = Patch(color="tomato", label="VRNA")
line_l = Patch(color="green", label="Line")
cont_l = Patch(color="blueviolet", label="Cont")
mx_l = Patch(color="darkslategrey", label="Mxfold")

fft_f.xaxis.set_ticklabels(list_len[::20], rotation=45)
fft_f.xaxis.set_ticks([i for i in range(nb_el)][::20])

name_fft = "FFT"
name_mfe = "VRNA"
name_cont = "ContextFold"
name_line = "Linear"
name_mx = "Mxfold"
fft_f.set_title(f"PVV")
# fft_f.legend((fft_l,mfe_l,line_l,cont_l, mx_l), (f"{name_fft}({fft_mean:4.1f})", f"{name_mfe}({mfe_mean:4.1f})",
#                                     f"{name_line}({line_mean:4.1f})", f"{name_cont}({cont_mean:4.1f})",
#                                     f"{name_mx}({mx_mean:4.1f})"), loc="bottom center", ncol=3)
fft_f.legend((fft_l,mfe_l,line_l), (f"{name_fft}({fft_mean:4.1f})", f"{name_mfe}({mfe_mean:4.1f})",
                                    f"{name_line}({line_mean:4.1f})"), loc="upper center", ncol=3)
# plt.savefig("img/comp_stack_pvv.png", dpi=300)
plt.show()
#+end_src

#+RESULTS:
: FFT 80 MFE 79 LINE 96 ONLY FFT 8 ONLY MFE 7 TOT 2293
* Sequence composition
#+begin_src python :results output
def read_csv(infile):
    results = []
    for l in open(infile):
        seq, struct, name = l.strip().split(",")
        results += [seq]
    return results

all_seq = read_csv("./kinetic_bench/benchmark_cleaned_all_length.csv")
len_li = [len(seq) for seq in all_seq]
print(min(len_li))
print(max(len_li))
#+end_src

#+RESULTS:
: 28
: 2968
* locally optimal

#+begin_src python :results output
from utils import paired_positions
import subprocess
import matplotlib.pyplot as plt
from matplotlib import rcParams, artist
from matplotlib.patches import Patch
from numpy import mean, std, median, linspace, arange
from scipy.stats import kde
from math import isnan
from RNA import fold_compound, bp_distance
from collections import defaultdict

plt.rcParams["font.family"] = "serif"
plt.rcParams["font.weight"] = "bold"
plt.rcParams["font.size"] = 6.7
plt.rcParams["figure.figsize"] = 8, 4


def read_true_struct(infile="./kinetic_bench/benchmark_cleaned_all_length.csv"):
    results = {}
    for l in open(infile):
        seq, struct, name = l.strip().split(",")
        if "<" not in struct:
            results[seq] = (struct, name)
    return results


def read_csv(infile):
    results = {}
    first = True
    for l in open(infile):
        if not first:
            seq, len_seq, struct, nrj, nb_bp, pvv, sens, name = l.strip().split(",")
            if struct != "Na":
                if pvv == "nan":
                    pvv = 0.0
                results[seq] = (int(len_seq), struct, float(nrj), int(nb_bp), float(pvv), float(sens))
        else:
            first = False
    return results


fft_pred = read_csv("./kinetic_bench/results_fft_all_length_100n_50ms_scores.csv")
# fft_pred = read_csv("./test_data/results_fft_100n_30_stack_scores.csv")
vrna_pred = read_csv("./test_data/results_mfe_scores.csv")
mx_pred = read_csv("./test_data/results_mxfold_scores.csv")
true_str = read_true_struct()

results_fft = defaultdict(lambda : 0)
results_mfe = defaultdict(lambda : 0)
results_mx = defaultdict(lambda : 0)
results_norm = defaultdict(lambda : 0)
for seq, (struct, name) in true_str.items():
    seq_comp = fold_compound(seq)

    true_nb_bp = struct.count("(")
    true_nrj = seq_comp.eval_structure(struct)
    if seq in fft_pred and seq in vrna_pred and seq in mx_pred:
        len_seq, fft_st, fft_nrj, fft_nbp, fft_pvv, fft_sens = fft_pred[seq]
        len_seq, mfe_st, mfe_nrj, mfe_nbp, mfe_pvv, mfe_sens = vrna_pred[seq]
        len_seq, mx_st, mx_nrj, mx_nbp, mx_pvv, mx_sens = mx_pred[seq]
        pair_list_mfe = paired_positions(mfe_st)
        pair_list_fft = paired_positions(fft_st)
        pair_list_mx = paired_positions(mx_st)
        pair_list_true = paired_positions(struct)

        for pi, pj in pair_list_true:
            dist = abs(pi - pj)

            if (pi, pj) in pair_list_mfe:
                results_mfe[dist] += 1.0

            if (pi, pj) in pair_list_fft:
                results_fft[dist] += 1.0
                    
            if (pi, pj) in pair_list_mx:
                results_mx[dist] += 1.0

            results_norm[dist] += 1.0
        

dist_list = list(results_norm.keys())
dist_list.sort()
dist_list = [d for d in dist_list if results_norm[d] > 20]
# pvv_list = [mean(results[d]) for d in dist_list]
pvv_list_mfe = [results_mfe[d]/results_norm[d] for d in dist_list]
pvv_list_fft = [results_fft[d]/results_norm[d] for d in dist_list]
pvv_list_mx = [results_mx[d]/results_norm[d] for d in dist_list]

nb_el = len(dist_list)
slide_mean_mfe = [mean([d for d in pvv_list_mfe[max(0, i-10):min(nb_el, i+10)]]) for i, d_ in enumerate(pvv_list_mfe)]
slide_mean_fft = [mean([d for d in pvv_list_fft[max(0, i-10):min(nb_el, i+10)]]) for i, d_ in enumerate(pvv_list_mfe)]
slide_mean_mx = [mean([d for d in pvv_list_mx[max(0, i-10):min(nb_el, i+10)]]) for i, d_ in enumerate(pvv_list_mfe)]


fig = plt.figure(1)
fft_f = fig.add_subplot(111)

fft_f.grid(True, color="grey",linestyle="--", linewidth=0.2)
fft_f.plot(dist_list, slide_mean_mfe, linestyle="--", c="orangered", alpha = 0.5)
fft_f.scatter(dist_list, pvv_list_mfe, c="orangered", alpha = 0.8, s=6)
fft_f.plot(dist_list, slide_mean_fft, linestyle="--", c="deepskyblue", alpha = 0.5)
fft_f.scatter(dist_list, pvv_list_fft, c="deepskyblue", alpha = 0.8, s=6)
fft_f.plot(dist_list, slide_mean_mx, linestyle="--", c="palegreen", alpha = 0.5)
fft_f.scatter(dist_list, pvv_list_mx, c="palegreen", alpha = 0.8, s=6)
# fft_f.scatter(dist_list, [results_norm[d] for d in dist_list])
plt.show()
#+end_src

#+RESULTS:
